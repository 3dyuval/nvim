=== ./lua/config/options.lua ===
-- Options are automatically loaded before lazy.nvim startup
-- Default options that are always set: https://github.com/LazyVim/LazyVim/blob/main/lua/lazyvim/config/options.lua
-- Add any additional options here

=== ./lua/config/autocmds.lua ===
-- Autocmds are automatically loaded on the VeryLazy event
-- Default autocmds that are always set: https://github.com/LazyVim/LazyVim/blob/main/lua/lazyvim/config/autocmds.lua
--
-- Add any additional autocmds here
-- with `vim.api.nvim_create_autocmd`
--
-- Or remove existing autocmds by their group name (which is prefixed with `lazyvim_` for the defaults)
-- e.g. vim.api.nvim_del_augroup_by_name("lazyvim_wrap_spell")

vim.api.nvim_create_autocmd("FileType", {
  pattern = { "snacks_win", "snacks_picker", "snacks_explorer" },
  callback = function()
    vim.opt_local.swapfile = false
  end,
})

vim.api.nvim_create_autocmd("FileType", {
  pattern = { "javascript", "typescript", "json", "lua", "python", "css", "scss" },
  callback = function()
    local pairs = require("mini.pairs")
    -- This should handle the {} expansion automatically
    -- If it doesn't work well, we'll use the custom keymap approach
  end,
})

-- Fix grug-far current file keymap override issue
vim.api.nvim_create_autocmd('FileType', {
  pattern = 'grug-far',
  callback = function()
    vim.keymap.set("n", "<leader>sr", function()
      require('grug-far').open({ prefills = { paths = vim.fn.expand("%") } })
    end, { desc = "Search and replace (current file)", buffer = true })
  end,
})

=== ./lua/config/keymaps.lua ===
-- Keymaps are automatically loaded on the VeryLazy event
-- Default keymaps that are always set: https://github.com/LazyVim/LazyVim/blob/main/lua/lazyvim/config/keymaps.lua
-- Add any additional keymaps here
local map = vim.keymap.set
-- Delete on 'q' (next to 'w' where change is)
map({ "n", "o", "x" }, "x", "d", { desc = "Delete" })

map({ "n" }, "<C-a>", "<cmd>bprevious<CR>", { desc = "Previous buffer" })
map({ "n" }, "<C-e>", "<cmd>bnext<CR>", { desc = "Next buffer" })
-- Smart buffer delete function
local function smart_buffer_delete()
  local bufs = vim.tbl_filter(function(buf)
    return vim.api.nvim_buf_is_loaded(buf) and vim.bo[buf].buflisted
  end, vim.api.nvim_list_bufs())

  if #bufs <= 1 then
    vim.cmd("bd")
    require("snacks").dashboard()
  else
    vim.cmd("bd")
  end
end

map({ "n" }, "<C-w>w", smart_buffer_delete, { desc = "Close buffer" })
map({ "n" }, "<C-w>o", "<cmd>%bd|e#<CR>", { desc = "Close all buffers but current" })
map({ "n" }, "<leader>bd", smart_buffer_delete, { desc = "Delete Buffer" })

-- Up/down/left/right
map({ "n", "o", "x" }, "h", "h", { desc = "Left (h)" })
map({ "n", "o", "x" }, "e", "k", { desc = "Up (k)" })
map({ "n", "o", "x" }, "a", "j", { desc = "Down (j)" })
map({ "n", "o", "x" }, "i", "l", { desc = "Right (l)" })

-- Line operations and find
map({ "n" }, "j", "o", { desc = "Open line below" })
map({ "n" }, "J", "O", { desc = "Open line above" })
-- f is now default (find character forward)
-- F is default (find character backward)

-- Beginning/end of line

map({ "n", "o", "x" }, "0", "0", { desc = "Beginning of line" })
map({ "n", "o", "x" }, "p", "^", { desc = "First non-blank character" })
map({ "n", "o", "x" }, ".", "$", { desc = "End of line" })

-- PageUp/PageDown
map({ "n", "x" }, "<C-.>", "<PageUp>", { desc = "Page Up" })
map({ "n", "x" }, "<C-p>", "<PageDown>", { desc = "Page Down" })

-- Jumplist navigation
-- map({ "n" }, "<C-e>", "<C-i>", { desc = "Jumplist forward" })
-- map({ "n" }, "<C-a>", "<C-o>", { desc = "Jumplist backward" })

-- Word left/right
map({ "n", "o", "x" }, "l", "b", { desc = "Word back" })
map({ "n", "o", "x" }, "d", "w", { desc = "Word forward" })
map({ "n", "o", "x" }, "L", "B", { desc = "WORD back" })
map({ "n", "o", "x" }, "D", "W", { desc = "WORD forward" })

-- Move lines with Alt+A/E
map({ "n" }, "<M-C-a>", "<cmd>move .+1<cr>==", { desc = "Move line down" })
map({ "n" }, "<M-C-e>", "<cmd>move .-2<cr>==", { desc = "Move line up" })

-- Search navigation (moved from <C-f> due to jumplist conflict)
map({ "n", "o", "x" }, "<C-s>", "n", { desc = "Next search match" })
map({ "n", "o", "x" }, "<C-S>", "N", { desc = "Previous search match" })

-- Repeat find
map({ "n", "o", "x" }, ";", ";", { desc = "Repeat find forward" })
map({ "n", "o", "x" }, "-", ",", { desc = "Repeat find backward" })

map({ "n", "o", "x" }, "%", "%", { desc = "Jump to matching bracket" })

-- End of word left/right
map({ "n", "o", "x" }, "H", "ge", { desc = "End of word back" })
map({ "n", "o", "x" }, "<M-h>", "gE", { desc = "End of WORD back" })
map({ "n", "o", "x" }, "<M-o>", "E", { desc = "End of WORD forward" })

-- Text objects
-- diw is drw. daw is now dtw.
map({ "n", "o", "v" }, "r", "i", { desc = "O/V mode: inner (i)" })
map({ "n", "o", "v" }, "t", "a", { desc = "O/V mode: a/an (a)" })

-- Simple operator-pending mappings for nvim-surround (using treesitter text objects)
map({ "o" }, "rd", "iw", { desc = "Inner word" })
map({ "o" }, "td", "aw", { desc = "Around word" })

-- Move visual replac.e from 'r' to 'R'
map({ "o", "v" }, "R", "r", { desc = "Replace" })

-- Folds
map({ "n", "x" }, "b", "z", { desc = "Fold commands" })
map({ "n", "x" }, "bb", "zb", { desc = "Scroll line and cursor to bottom" })
map({ "n", "x" }, "ba", "zj", { desc = "Move down to fold" })
map({ "n", "x" }, "be", "zk", { desc = "Move up to fold" })

-- Copy/paste
map({ "n", "o", "x" }, "c", "y", { desc = "Yank (copy)" })
map({ "n", "x" }, "v", "p", { desc = "Paste" })
map({ "n" }, "C", "y$", { desc = "Yank to end of line" })
map({ "x" }, "C", "y", { desc = "Yank selection" })
map({ "n", "x" }, "V", "P", { desc = "Paste before" })
map({ "v" }, "V", "P", { desc = "Paste without losing clipboard" })

-- Inline paste (avoids creating new lines)
local function paste_inline()
  local reg_type = vim.fn.getregtype('"')
  if reg_type == 'V' then -- line-wise register
    vim.cmd('normal! gp')
  else
    vim.cmd('normal! p')
  end
end

map({ "n", "x" }, "-", paste_inline, { desc = "Paste inline" })

-- Undo/redo
map({ "n" }, "z", "u", { desc = "Undo" })
map({ "n" }, "<S-u>", "U", { desc = "Undo line" })
map({ "n" }, "<C-u>", "<C-r>", { desc = "Redo" })

-- Jumplist navigation
map({ "n" }, "o", "<C-o>", { desc = "Jumplist backward" })
map({ "n" }, "<C-o>", "<C-i>", { desc = "Jumplist forward" })

-- Insert/append
map({ "n" }, "t", "i", { desc = "Insert before cursor" })
map({ "n" }, "T", "I", { desc = "Insert at start of line" })
map({ "n" }, "s", "a", { desc = "Insert after cursor" })
map({ "n" }, "S", "A", { desc = "Insert at end of line" })

map({ "v" }, "s", "<Plug>(nvim-surround-visual)", { desc = "Surround visual selection" })

-- Normal mode - Direct commenting with next line
map("n", "<C-/>", function()
  -- Call vim's native comment function directly
  vim.cmd('normal! ' .. vim.api.nvim_replace_termcodes('gcc', true, false, true))
  vim.cmd("normal! j")
end, { desc = "Toggle comment and go to next line" })

map("n", "<C-_>", function()
  -- Call vim's native comment function directly
  vim.cmd('normal! ' .. vim.api.nvim_replace_termcodes('gcc', true, false, true))
  vim.cmd("normal! j")
end, { desc = "Toggle comment and go to next line" })

-- Visual mode - Robust block commenting  
map("v", "<C-/>", function()
  local ok, comment_api = pcall(require, "Comment.api")
  if ok then
    comment_api.toggle.linewise(vim.fn.visualmode())
  else
    vim.cmd("'<,'>normal! gcc")
  end
end, { desc = "Toggle comment (visual)" })

map("v", "<C-_>", function()
  local ok, comment_api = pcall(require, "Comment.api")
  if ok then
    comment_api.toggle.linewise(vim.fn.visualmode())
  else
    vim.cmd("'<,'>normal! gcc")
  end
end, { desc = "Toggle comment (visual)" })

-- Change
map({ "n", "o", "x" }, "w", "c", { desc = "Change" })
map({ "n", "x" }, "W", "C", { desc = "Change to end of line" })

-- Visual mode
map({ "n", "x" }, "n", "v", { desc = "Visual mode" })
map({ "n", "x" }, "N", "V", { desc = "Visual line mode" })
-- Add Visual block mode
map({ "n" }, "<C-n>", "<C-v>", { desc = "Visual block mode" })

-- Override HAEI navigation in visual modes (including visual line mode)
-- Use noremap to fully override default vim behavior including text objects
vim.keymap.set("x", "e", "k", { noremap = true, desc = "Up in visual modes" })
vim.keymap.set("x", "a", "j", { noremap = true, desc = "Down in visual modes" })
vim.keymap.set("x", "h", "h", { noremap = true, desc = "Left in visual modes" })
vim.keymap.set("x", "i", "l", { noremap = true, desc = "Right in visual modes" })

-- Insert in Visual mode
map({ "v" }, "S", "I", { desc = "Insert at start of selection" })

map({ "n", "o", "x" }, "m", "n", { desc = "Next search match" })
map({ "n", "o", "x" }, "M", "N", { desc = "Previous search match" })

map({ "n" }, "<leader>gn", "<cmd>:Neogit cwd=%:p:h<CR>", { desc = "Open neogit" })
map({ "n" }, "<leader>gh", function()
  Snacks.terminal("gh dash", { win = { style = "terminal" } })
end, { desc = "Open GitHub dashboard" })

-- Lazygit
map({ "n" }, "<leader>gz", function()
  Snacks.lazygit()
end, { desc = "Lazygit (Root Dir)" })
map({ "n" }, "<leader>gZ", function()
  Snacks.lazygit({ cwd = LazyVim.root.get() })
end, { desc = "Lazygit (cwd)" })
-- 'til
map({ "n", "o", "x" }, "k", "t", { desc = "Till before" })
map({ "n", "o", "x" }, "K", "T", { desc = "Till before backward" })

-- Fix diffput (t for 'transfer')
-- map({ "n" }, "dt", "dp", { desc = "diffput (t for 'transfer')" })

-- Force override any plugin mappings for Q
vim.keymap.set("n", "Q", "@q", { desc = "replay the 'q' macro", silent = true, noremap = true })

-- Cursor to bottom of screen
-- H and M haven't been remapped, only L needs to be mapped
map({ "n" }, "B", "L", { desc = "Move to bottom of screen" })
map({ "v" }, "B", "L", { desc = "Move to bottom of screen" })
map({ "n", "v" }, "H", "H", { desc = "Move to top of screen" })

-- Misc overridden keys must be prefixed with g
map({ "n", "x" }, "gX", "X", { desc = "Delete before cursor" })
map({ "n", "x" }, "gU", "U", { desc = "Uppercase" })
map({ "n", "x" }, "gQ", "Q", { desc = "Ex mode" })
map({ "n", "x" }, "gK", "K", { desc = "Lookup keyword" })
-- extra alias (now main since K is remapped)
map({ "n", "x" }, "gh", "K", { desc = "Lookup keyword" })

-- Disable spawning empty buffer when closing last buffer
vim.api.nvim_create_autocmd("User", {
  pattern = "BufferClose",
  callback = function()
    local bufs = vim.tbl_filter(function(buf)
      return vim.api.nvim_buf_is_loaded(buf) and vim.bo[buf].buflisted
    end, vim.api.nvim_list_bufs())

    if #bufs == 0 then
      vim.schedule(function()
        require("snacks").dashboard()
      end)
    end
  end,
})

-- Window navigation - cycle through windows
map({ "n" }, "<C-h>", "<C-w>w", { desc = "Previous window" })
map({ "n" }, "<C-i>", "<C-w>W", { desc = "Next window" })
-- Directional window navigation (commented out due to buffer nav conflicts)
-- map({ "n" }, "<C-a>", "<C-w>j", { desc = "Window down" })
-- map({ "n" }, "<C-e>", "<C-w>k", { desc = "Window up" })

-- Add some commonly used editor operations
map({ "n" }, "<leader>fs", ":w<CR>", { desc = "Save file" })
map({ "n" }, "<leader>q", ":q<CR>", { desc = "Quit" })
map({ "n" }, "<leader>Q", ":qa<CR>", { desc = "Quit all" })
map({ "n" }, "<leader>rr", function()
  vim.cmd("source " .. vim.fn.stdpath("config") .. "/lua/config/keymaps.lua")
  vim.notify("Keymaps reloaded")
end, { desc = "Reload keymaps" })

map({ "n" }, "<leader>rl", "<cmd>Lazy sync<cr>", { desc = "Lazy sync plugins" })
map({ "n" }, "<leader>ct", function()
  vim.cmd("split | terminal tsc --noEmit")
end, { desc = "TypeScript type check" })

map({ "n", "i", "v" }, "<F1>", "<nop>", { desc = "Disabled" })
map({ "n" }, "<F2>", "ggVG", { desc = "Select all" })

map({ "n", "o", "x" }, "<C-`>", function()
  Snacks.terminal()
end, { desc = "Toggle Terminal" })

-- Copy entire file contents to clipboard
map({ "n" }, "<C-S-p>", function()
  -- Save current cursor position
  local cursor_pos = vim.fn.getpos(".")

  -- Select all content and yank to clipboard
  vim.cmd('normal! ggVG"+y')

  -- Restore cursor position
  vim.fn.setpos(".", cursor_pos)

  -- Get file info for notification
  local filename = vim.fn.expand("%:t")
  local line_count = vim.fn.line("$")
  vim.notify(string.format("File copied to clipboard: %s (%d lines)", filename, line_count))
end, { desc = "Copy file contents to clipboard" })

map({ "v" }, "re", function()
  require("nvim-treesitter.textobjects.select").select_textobject("@element.inner", "textobjects")
end, { desc = "Select inner JSX element" })

map({ "v" }, "te", function()
  require("nvim-treesitter.textobjects.select").select_textobject("@element.outer", "textobjects")
end, { desc = "Select around JSX element" })

map({ "v" }, "rh", function()
  require("nvim-treesitter.textobjects.select").select_textobject("@tag.inner", "textobjects")
end, { desc = "Select inner HTML tag" })

map({ "v" }, "th", function()
  require("nvim-treesitter.textobjects.select").select_textobject("@tag.outer", "textobjects")
end, { desc = "Select around HTML tag" })

-- Operator-pending mode mappings to help with nvim-surround
-- These allow your r/t mappings to work in operator-pending mode
map({ "v" }, "rd", "iw", { desc = "Inner word (visual)" })
map({ "v" }, "td", "aw", { desc = "Around word (visual)" })
map({ "o" }, "r(", "i(", { desc = "Inner parentheses (for nvim-surround)" })
map({ "o" }, "r)", "i)", { desc = "Inner parentheses (for nvim-surround)" })
map({ "o" }, "r[", "i[", { desc = "Inner brackets (for nvim-surround)" })
map({ "o" }, "r]", "i]", { desc = "Inner brackets (for nvim-surround)" })
map({ "o" }, "r{", "i{", { desc = "Inner braces (for nvim-surround)" })
map({ "o" }, "r}", "i}", { desc = "Inner braces (for nvim-surround)" })
map({ "o" }, 'r"', 'i"', { desc = "Inner quotes (for nvim-surround)" })
map({ "o" }, "r'", "i'", { desc = "Inner single quotes (for nvim-surround)" })
map({ "o" }, "t(", "a(", { desc = "Around parentheses (for nvim-surround)" })
map({ "o" }, "t)", "a)", { desc = "Around parentheses (for nvim-surround)" })
map({ "o" }, "t[", "a[", { desc = "Around brackets (for nvim-surround)" })
map({ "o" }, "t]", "a]", { desc = "Around brackets (for nvim-surround)" })
map({ "o" }, "t{", "a{", { desc = "Around braces (for nvim-surround)" })
map({ "o" }, "t}", "a}", { desc = "Around braces (for nvim-surround)" })
map({ "o" }, 't"', 'a"', { desc = "Around quotes (for nvim-surround)" })
map({ "o" }, "t'", "a'", { desc = "Around single quotes (for nvim-surround)" })

-- Snacks keymaps
local snacks_keymaps = require("config.keymaps-snacks")
map({ "n" }, "<leader>ti", snacks_keymaps.toggle_ignored, { desc = "Toggle snacks picker ignored files" })
map({ "n" }, "<leader>th", snacks_keymaps.toggle_hidden, { desc = "Toggle snacks picker hidden files" })

-- Default bracket and paragraph navigation restored
-- [ and ] are default (previous/next navigation)
-- { and } are default (previous/next paragraph)

-- TypeScript Go to Source Definition with fallback to regular definition
map("n", "<leader>cc", function()
  local clients = vim.lsp.get_clients({ bufnr = 0 })
  if #clients == 0 then
    vim.notify("No LSP client attached", vim.log.levels.WARN)
    return
  end
  
  local position_params = vim.lsp.util.make_position_params(0, clients[1].offset_encoding)
  
  vim.lsp.buf_request(0, "workspace/executeCommand", {
    command = "typescript.goToSourceDefinition",
    arguments = { position_params.textDocument.uri, position_params.position },
  }, function(err, result, ctx, config)
    if err then
      vim.notify("Error: " .. tostring(err), vim.log.levels.ERROR)
      return
    end
    
    if not result or (type(result) == "table" and #result == 0) then
      vim.notify("No source definition found, trying regular definition", vim.log.levels.INFO)
      -- First try gd (floating window), then fall back to opening in new buffer
      vim.lsp.buf.definition({
        on_list = function(options)
          if options.items and #options.items > 0 then
            local item = options.items[1]
            vim.cmd('edit ' .. item.filename)
            vim.api.nvim_win_set_cursor(0, {item.lnum, item.col - 1})
          end
        end
      })
      return
    end
    
    local location = result
    if type(result) == "table" and result[1] then
      location = result[1]
    end
    
    vim.lsp.util.jump_to_location(location, "utf-8")
  end)
end, { desc = "Go to source definition (fallback to definition)" })


-- Grug-far search within range
map({ "n", "x" }, "<leader>sR", function()
  require('grug-far').open({ visualSelectionUsage = 'operate-within-range' })
end, { desc = "Search within range" })

=== ./lua/config/keymaps-snacks.lua ===
-- Snacks-related keymaps module
local M = {}

-- Generic toggle function for snacks picker settings
local function toggle_snacks_picker_setting(setting_name)
  return function()
    local snacks = require("snacks")
    local current_value = snacks.config.picker[setting_name]
    snacks.config.picker[setting_name] = not current_value
    local status = snacks.config.picker[setting_name] and "enabled" or "disabled"
    vim.notify("Snacks picker " .. setting_name .. " files: " .. status)
  end
end

-- Export toggle function
M.toggle_snacks_picker_setting = toggle_snacks_picker_setting

-- Export individual toggle functions
M.toggle_ignored = toggle_snacks_picker_setting("ignored")
M.toggle_hidden = toggle_snacks_picker_setting("hidden")

return M

=== ./lua/config/lazy.lua ===
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not (vim.uv or vim.loop).fs_stat(lazypath) then
  local lazyrepo = "https://github.com/folke/lazy.nvim.git"
  local out = vim.fn.system({ "git", "clone", "--filter=blob:none", "--branch=stable", lazyrepo, lazypath })
  if vim.v.shell_error ~= 0 then
    vim.api.nvim_echo({
      { "Failed to clone lazy.nvim:\n", "ErrorMsg" },
      { out, "WarningMsg" },
      { "\nPress any key to exit..." },
    }, true, {})
    vim.fn.getchar()
    os.exit(1)
  end
end
vim.opt.rtp:prepend(lazypath)

require("lazy").setup({
  spec = {
    -- add LazyVim and import its plugins
    { "LazyVim/LazyVim", import = "lazyvim.plugins" },
    -- import/override with your plugins
    { import = "plugins" },
  },
  defaults = {
    -- By default, only LazyVim plugins will be lazy-loaded. Your custom plugins will load during startup.
    -- If you know what you're doing, you can set this to `true` to have all your custom plugins lazy-loaded by default.
    lazy = false,
    -- It's recommended to leave version=false for now, since a lot the plugin that support versioning,
    -- have outdated releases, which may break your Neovim install.
    version = false, -- always use the latest git commit
    -- version = "*", -- try installing the latest stable version for plugins that support semver
  },
  install = { colorscheme = { "tokyonight", "habamax" } },
  checker = {
    enabled = true, -- check for plugin updates periodically
    notify = false, -- notify on update
  }, -- automatically check for plugin updates
  performance = {
    rtp = {
      -- disable some rtp plugins
      disabled_plugins = {
        "gzip",
        -- "matchit",
        -- "matchparen",
        -- "netrwPlugin",
        "tarPlugin",
        "tohtml",
        "tutor",
        "zipPlugin",
      },
    },
  },
})


=== ./lua/plugins/octo.lua ===
return {
  "pwntester/octo.nvim",
  cmd = "Octo",
  dependencies = {
    "nvim-lua/plenary.nvim",
    "nvim-telescope/telescope.nvim",
    "nvim-tree/nvim-web-devicons",
  },
  config = function()
    require("octo").setup({ enable_builtin = true })
    vim.cmd([[hi OctoEditable guibg=none]])
  end,
  keys = {
    { "<leader>o", "<cmd>Octo<cr>", desc = "Octo" },
  },
}
=== ./lua/plugins/flash.lua ===
return {
  "folke/flash.nvim",
  lazy = false,
  priority = 1000,
  enabled = false, -- Completely disable Flash
  -- keys = {}, -- Remove all default keymaps
}

=== ./lua/plugins/neogit.lua ===
return {
  "NeogitOrg/neogit",
  opts = {
    kind = "vsplit",
    -- floating = {
    -- relative = "editor",
    -- width = 0.95,
    -- height = 0.90,
    -- style = "minimal",
    -- border = "rounded",
    -- },
    keymaps = {},
    autoinstall = true,
  },
  dependencies = {
    "nvim-lua/plenary.nvim", -- required
    "sindrets/diffview.nvim", -- optional - Diff integration

    -- Only one of these is needed.
    "nvim-telescope/telescope.nvim", -- optional
    "ibhagwan/fzf-lua", -- optional
    "echasnovski/mini.pick", -- optional
    "folke/snacks.nvim", -- optional
  },
}

=== ./lua/plugins/telescope.lua ===
return {
  {
    "nvim-telescope/telescope.nvim",
    dependencies = {
      "nvim-lua/plenary.nvim",
      {
        "nvim-telescope/telescope-fzf-native.nvim",
        build = "make",
      },
    },
    keys = {
      { "<leader>ff", "<cmd>Telescope find_files<cr>", desc = "Find Files" },
      { "<leader>fg", "<cmd>Telescope live_grep<cr>", desc = "Live Grep" },
      { "<leader>fb", "<cmd>Telescope buffers<cr>", desc = "Buffers" },
      { "<leader>fh", "<cmd>Telescope help_tags<cr>", desc = "Help Tags" },
      { "<leader>fr", "<cmd>Telescope oldfiles<cr>", desc = "Recent Files" },
      { "<leader>fc", "<cmd>Telescope commands<cr>", desc = "Commands" },
      { "<leader>:", "<cmd>Telescope command_history<cr>", desc = "Command History" },
      { "<leader>fw", "<cmd>Telescope grep_string<cr>", desc = "Find Word Under Cursor" },
    },
    opts = {
      defaults = {
        layout_strategy = "horizontal",
        layout_config = {
          horizontal = {
            prompt_position = "top",
            preview_width = 0.55,
            results_width = 0.8,
          },
          vertical = {
            mirror = false,
          },
          width = 0.87,
          height = 0.80,
          preview_cutoff = 120,
        },
        path_display = { "truncate" },
        winblend = 0,
        sorting_strategy = "ascending",
        file_ignore_patterns = { "node_modules", ".git/" },
      },
      extensions = {
        fzf = {
          fuzzy = true,
          override_generic_sorter = true,
          override_file_sorter = true,
          case_mode = "smart_case",
        },
      },
    },
    config = function(_, opts)
      local telescope = require("telescope")
      telescope.setup(opts)
      telescope.load_extension("fzf")
      -- Enable noice.nvim integration if available
      pcall(function() telescope.load_extension("noice") end)
    end,
  },
}
=== ./lua/plugins/treesitter-main.lua ===
return {
  "nvim-treesitter/nvim-treesitter",
  opts = function(_, opts)
    -- Ensure JSX/TSX parsers are installed
    opts.ensure_installed = opts.ensure_installed or {}
    vim.list_extend(opts.ensure_installed, {
      "javascript",
      "typescript", 
      "tsx",
      "html",
      "css"
    })
    
    -- Enable autotag integration (Takuya's way)
    opts.autotag = {
      enable = true,
    }
    
    return opts
  end,
}
=== ./lua/plugins/typescript-extras.lua ===
return {
  -- Show TypeScript errors in virtual text with better formatting
  {
    "https://git.sr.ht/~whynothugo/lsp_lines.nvim",
    event = "LspAttach",
    config = function()
      require("lsp_lines").setup()
      -- Disable virtual_text since lsp_lines replaces it
      vim.diagnostic.config({
        virtual_text = false,
      })
    end,
  },

  -- TypeScript hover information with better formatting
  {
    "rmagatti/goto-preview",
    event = "BufEnter",
    config = function()
      require('goto-preview').setup {
        width = 120,
        height = 25,
        default_mappings = false,
        debug = false,
        opacity = nil,
        post_open_hook = nil
      }
    end,
    keys = {
      { "gpd", "<cmd>lua require('goto-preview').goto_preview_definition()<CR>", desc = "Preview Definition" },
      { "gpt", "<cmd>lua require('goto-preview').goto_preview_type_definition()<CR>", desc = "Preview Type Definition" },
      { "gpi", "<cmd>lua require('goto-preview').goto_preview_implementation()<CR>", desc = "Preview Implementation" },
      { "gpr", "<cmd>lua require('goto-preview').goto_preview_references()<CR>", desc = "Preview References" },
      { "gP", "<cmd>lua require('goto-preview').close_all_win()<CR>", desc = "Close All Previews" },
    },
  },

  -- Better TypeScript error highlighting and type information
  {
    "folke/trouble.nvim",
    opts = {
      -- Remove icons config since LazyVim handles this
      fold_open = "v",
      fold_closed = ">",
      indent_lines = false,
    },
  },
}
=== ./lua/plugins/todo-comments.lua ===
return {
  "folke/todo-comments.nvim",
  cmd = { "TodoTrouble", "TodoTelescope" },
  event = "LazyFile",
  opts = {},
  -- stylua: ignore
  keys = {
    { "]t", function() require("todo-comments").jump_next() end, desc = "Next Todo Comment" },
    { "[t", function() require("todo-comments").jump_prev() end, desc = "Previous Todo Comment" },
    { "<leader>xt", "<cmd>Trouble todo toggle<cr>", desc = "Todo (Trouble)" },
    { "<leader>xT", "<cmd>Trouble todo toggle filter = {tag = {TODO,FIX,FIXME}}<cr>", desc = "Todo/Fix/Fixme (Trouble)" },
    { "<leader>st", "<cmd>TodoTelescope<cr>", desc = "Todo" },
    { "<leader>sT", "<cmd>TodoTelescope keywords=TODO,FIX,FIXME<cr>", desc = "Todo/Fix/Fixme" },
  },
}

=== ./lua/plugins/comment.lua ===
return {
  {
    "folke/ts-comments.nvim",
    opts = {},
    event = "VeryLazy",
    enabled = vim.fn.has("nvim-0.10.0") == 1,
  },
  {
    "numToStr/Comment.nvim",
    opts = {},
    event = "VeryLazy",
    enabled = vim.fn.has("nvim-0.10.0") == 0, -- Fallback for older versions
  },
}

=== ./lua/plugins/snacks.lua ===
-- https://github.com/folke/snacks.nvim/blob/main/docs/picker.md
return {
  "folke/snacks.nvim",
  enabled = true,
  ---@type snacks.Config
  opts = {
    dashboard = {
      enabled = true,
      sections = {
        { section = "header" },
        { section = "keys", gap = 1, padding = 1 },
        { section = "startup" },
      },
      preset = {
        keys = {
          {
            icon = " ",
            key = "e",
            desc = "Explorer",
            action = function()
              LazyVim.pick("explorer", { root = false })()
            end,
          },
          { icon = " ", key = "n", desc = "New File", action = ":ene | startinsert" },
          { icon = " ", key = "g", desc = "Find Text", action = ":lua Snacks.dashboard.pick('live_grep')" },
          { icon = " ", key = "r", desc = "Recent Files", action = ":lua Snacks.dashboard.pick('oldfiles')" },
          {
            icon = " ",
            key = "p",
            desc = "Projects",
            action = function()
              LazyVim.pick("projects")()
            end,
          },
          {
            icon = " ",
            key = "c",
            desc = "Config",
            action = ":lua Snacks.dashboard.pick('files', {cwd = vim.fn.stdpath('config')})",
          },
          { icon = " ", key = "s", desc = "Restore Session", section = "session" },
          { icon = "󰒲 ", key = "l", desc = "Lazy", action = ":Lazy", enabled = package.loaded.lazy ~= nil },
          { icon = " ", key = "q", desc = "Quit", action = ":qa" },
        },
      },
    },
    picker = {
      enabled = true,
      hidden = true,
      ignored = false,
      win = {
        list = {
          keys = {
            ["a"] = "list_down", -- Remap 'a' to down movement (HAEI layout)
            ["c"] = "create", -- Remap 'c' to create file/folder
          },
        },
      },
      sources = {
        explorer = {
          auto_close = true,
          hidden = true,
          layout = {
            preset = "default",
            preview = false,
          },
          filter = function(item)
            -- Default explorer behavior - show all files and directories
            return true
          end,
          actions = {
            open_multiple_buffers = {
              action = function(picker)
                local sel = picker.list.selected or {}

                if #sel == 0 then
                  vim.notify("No files selected", vim.log.levels.WARN)
                  return
                end

                picker:close()

                for _, item in ipairs(sel) do
                  if item and item.file then
                    vim.cmd("edit " .. vim.fn.fnameescape(item.file))
                  end
                end

                vim.notify(string.format("Opened %d file(s)", #sel))
              end,
            },
            copy_file_path = {
              action = function(_, item)
                if not item then
                  return
                end
                local vals = {
                  ["PATH"] = item.file,
                  ["FILE CONTENT"] = "file_content",
                  ["PATH (HOME)"] = vim.fn.fnamemodify(item.file, ":~"),
                  ["PATH (CWD)"] = vim.fn.fnamemodify(item.file, ":."),
                  ["BASENAME"] = vim.fn.fnamemodify(item.file, ":t:r"),
                  ["EXTENSION"] = vim.fn.fnamemodify(item.file, ":t:e"),
                  ["FILENAME"] = vim.fn.fnamemodify(item.file, ":t"),
                  ["URI"] = vim.uri_from_fname(item.file),
                }
                local options = vim.tbl_filter(function(val)
                  return vals[val] ~= ""
                end, vim.tbl_keys(vals))
                if vim.tbl_isempty(options) then
                  vim.notify("No values to copy", vim.log.levels.WARN)
                  return
                end
                vim.ui.select(options, {
                  prompt = "Choose to copy to clipboard:",
                  format_item = function(list_item)
                    return ("%s: %s"):format(list_item, vals[list_item])
                  end,
                }, function(choice)
                  local result = vals[choice]
                  if result then
                    if choice == "FILE CONTENT" then
                      if vim.fn.filereadable(item.file) == 0 then
                        vim.notify("File not readable: " .. item.file, vim.log.levels.ERROR)
                        return
                      end
                      local content = vim.fn.readfile(item.file)
                      local content_str = table.concat(content, "\n")
                      vim.fn.setreg("+", content_str)
                      local filename = vim.fn.fnamemodify(item.file, ":t")
                      local line_count = #content
                      Snacks.notify.info(
                        string.format("File content copied to clipboard: %s (%d lines)", filename, line_count)
                      )
                    else
                      vim.fn.setreg("+", result)
                      Snacks.notify.info("Yanked `" .. result .. "`")
                    end
                  end
                end)
              end,
            },
            search_in_directory = {
              action = function(_, item)
                if not item then
                  return
                end
                local dir = vim.fn.fnamemodify(item.file, ":p:h")
                Snacks.picker.grep({
                  cwd = dir,
                  cmd = "rg",
                  args = {
                    "-g",
                    "!.git",
                    "-g",
                    "!node_modules",
                    "-g",
                    "!dist",
                    "-g",
                    "!build",
                    "-g",
                    "!coverage",
                    "-g",
                    "!.DS_Store",
                    "-g",
                    "!.docusaurus",
                    "-g",
                    "!.dart_tool",
                  },
                  show_empty = true,
                  hidden = true,
                  ignored = true,
                  follow = false,
                  supports_live = true,
                })
              end,
            },
            diff = {
              action = function(picker)
                picker:close()
                local sel = picker:selected()
                if #sel > 0 and sel then
                  Snacks.notify.info(sel[1].file)
                  vim.cmd("tabnew " .. sel[1].file)
                  vim.cmd("vert diffs " .. sel[2].file)
                  Snacks.notify.info("Diffing " .. sel[1].file .. " against " .. sel[2].file)
                  return
                end
                Snacks.notify.info("Select two entries for the diff")
              end,
            },
          },
          win = {
            list = {
              keys = {
                ["a"] = "list_down", -- Remap 'a' to down movement (HAEI layout)
                ["p"] = "copy_file_path",
                ["s"] = "search_in_directory",
                ["D"] = "diff",
                ["r"] = "explorer_add", -- Create file/folder
                ["x"] = false, -- Disable default x binding
                ["R"] = "explorer_rename", -- Rename on 'R',
                ["<C-o>"] = "open_multiple_buffers", -- This references the action above,
              },
            },
          },
        },
        files = {
          cmd = "fd",
          args = {
            "--color=never",
            "--type",
            "f",
            "--type",
            "l",
            "--hidden",
            "--follow",
            "--exclude",
            ".git",
            "--exclude",
            "node_modules",
          },
        },
        grep = {
          cmd = "rg",
          args = {
            "--color=never",
            "--no-heading",
            "--with-filename",
            "--line-number",
            "--column",
            "--smart-case",
            "--hidden",
            "--glob",
            "!.git/*",
            "--glob",
            "!node_modules/*",
          },
        },
      },
    },
  },
  keys = {
    {
      "<leader>o",
      function()
        -- Get list of currently opened buffer file paths
        local open_files = {}
        for _, buf in ipairs(vim.api.nvim_list_bufs()) do
          if vim.api.nvim_buf_is_loaded(buf) and vim.bo[buf].buflisted then
            local file_path = vim.api.nvim_buf_get_name(buf)
            if file_path ~= "" then
              table.insert(open_files, {
                file = file_path,
                text = vim.fn.fnamemodify(file_path, ":t"),
                icon = "󰈔",
                kind = "file",
              })
            end
          end
        end

        -- Create a picker with custom items but explorer behavior
        Snacks.picker.pick("open_files", {
          items = open_files,
          actions = Snacks.config.picker.sources.explorer.actions,
          win = Snacks.config.picker.sources.explorer.win,
        })
      end,
      desc = "Explorer (open files only)",
    },
  },
}

=== ./lua/plugins/disable-codelens.lua ===
return {
  "neovim/nvim-lspconfig",
  opts = function()
    local keys = require("lazyvim.plugins.lsp.keymaps").get()
    -- Disable the codelens keymap
    keys[#keys + 1] = { "<leader>cc", false }
  end,
}
=== ./lua/plugins/dap.lua ===
return {
    "mfussenegger/nvim-dap",
    event = "VeryLazy",
    dependencies = {
        "rcarriga/nvim-dap-ui",
        "nvim-neotest/nvim-nio",
        "jay-babu/mason-nvim-dap.nvim",
        "theHamsta/nvim-dap-virtual-text",
    },
    config = function()
        local mason_dap = require("mason-nvim-dap")
        local dap = require("dap")
        local ui = require("dapui")
        local dap_virtual_text = require("nvim-dap-virtual-text")

        -- Dap Virtual Text
        dap_virtual_text.setup()

        -- Enable debug logging
        dap.set_log_level('DEBUG')

        mason_dap.setup({
            ensure_installed = { "js-debug-adapter" },
            automatic_installation = true,
            handlers = {
                function(config)
                    require("mason-nvim-dap").default_setup(config)
                end,
            },
        })

        -- Configure pwa-node adapter (js-debug-adapter)
        local js_debug_path = vim.fn.stdpath("data") .. "/mason/packages/js-debug-adapter/js-debug-adapter"
        dap.adapters["pwa-node"] = {
            type = "server",
            host = "localhost",
            port = "${port}",
            executable = {
                command = js_debug_path,
                args = { "${port}" },
            }
        }

        -- Configure pwa-chrome adapter (same js-debug-adapter)
        dap.adapters["pwa-chrome"] = {
            type = "server",
            host = "localhost",
            port = "${port}",
            executable = {
                command = js_debug_path,
                args = { "${port}" },
            }
        }

        -- JavaScript/Node.js configurations
        dap.configurations.javascript = {
            {
                name = "Launch",
                type = "pwa-node",
                request = "launch",
                program = "${file}",
                cwd = vim.fn.getcwd(),
                sourceMaps = true,
            },
            {
                name = "Attach to process",
                type = "pwa-node",
                request = "attach",
                processId = require("dap.utils").pick_process,
            },
        }

        -- TypeScript configurations (same as JavaScript)
        dap.configurations.typescript = dap.configurations.javascript

        -- Load project-specific .vscode/launch.json files
        require('dap.ext.vscode').load_launchjs(nil, { 
            ['pwa-node'] = {'javascript', 'typescript', 'javascriptreact', 'typescriptreact'},
            ['pwa-chrome'] = {'javascript', 'typescript', 'javascriptreact', 'typescriptreact'}
        })

        -- Dap UI
        ui.setup()
        vim.fn.sign_define("DapBreakpoint", { text = "🐞" })

        dap.listeners.before.attach.dapui_config = function()
            ui.open()
        end
        dap.listeners.before.launch.dapui_config = function()
            ui.open()
        end
        dap.listeners.before.event_terminated.dapui_config = function()
            ui.close()
        end
        dap.listeners.before.event_exited.dapui_config = function()
            ui.close()
        end

        -- Debug keymaps
        vim.keymap.set("n", "<leader>dt", function() dap.toggle_breakpoint() end, { desc = "Toggle Breakpoint" })
        vim.keymap.set("n", "<leader>dc", function() dap.continue() end, { desc = "Continue" })
        vim.keymap.set("n", "<leader>di", function() dap.step_into() end, { desc = "Step Into" })
        vim.keymap.set("n", "<leader>do", function() dap.step_over() end, { desc = "Step Over" })
        vim.keymap.set("n", "<leader>du", function() dap.step_out() end, { desc = "Step Out" })
        vim.keymap.set("n", "<leader>dr", function() dap.repl.open() end, { desc = "Open REPL" })
        vim.keymap.set("n", "<leader>dl", function() dap.run_last() end, { desc = "Run Last" })
        vim.keymap.set("n", "<leader>dq", function() 
            dap.terminate()
            ui.close()
        end, { desc = "Terminate" })
        vim.keymap.set("n", "<leader>db", function() dap.list_breakpoints() end, { desc = "List Breakpoints" })
    end,
}


=== ./lua/plugins/autotag.lua ===
return {
  "windwp/nvim-ts-autotag",
  event = { "BufReadPre", "BufNewFile" },
  ft = { "html", "css", "javascript", "typescript", "javascriptreact", "typescriptreact", "vue", "svelte" },
  dependencies = { "nvim-treesitter/nvim-treesitter" },
  config = function()
    require("nvim-ts-autotag").setup({
      opts = {
        enable_close = true,          -- Auto close tags
        enable_rename = true,         -- Auto rename pairs of tags
        enable_close_on_slash = false -- Auto close on trailing </
      },
      per_filetype = {
        ["html"] = {
          enable_close = true
        },
        ["javascript"] = {
          enable_close = true
        },
        ["typescript"] = {
          enable_close = true
        },
        ["javascriptreact"] = {
          enable_close = true
        },
        ["typescriptreact"] = {
          enable_close = true
        }
      }
    })
  end,
}
=== ./lua/plugins/surround.lua ===
local M = {}

---@type user_options
M.default_opts = {
  keymaps = {
    insert = "<C-g>s",
    insert_line = "<C-g>S",
    normal = "ys",
    normal_cur = "yss",
    normal_line = "yS",
    normal_cur_line = "ySS",
    visual = "s",
    visual_line = "gS",
    delete = "xs",
    change = "cs",
    change_line = "cS",
  },
  surrounds = {
    ["("] = {
      add = { "( ", " )" },
      find = function()
        return M.get_selection({ motion = "a(" })
      end,
      delete = "^(. ?)().-( ?.)()$",
    },
    [")"] = {
      add = { "(", ")" },
      find = function()
        return M.get_selection({ motion = "a)" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["{"] = {
      add = { "{ ", " }" },
      find = function()
        return M.get_selection({ motion = "a{" })
      end,
      delete = "^(. ?)().-( ?.)()$",
    },
    ["}"] = {
      add = { "{", "}" },
      find = function()
        return M.get_selection({ motion = "a}" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["<"] = {
      add = { "< ", " >" },
      find = function()
        return M.get_selection({ motion = "a<" })
      end,
      delete = "^(. ?)().-( ?.)()$",
    },
    [">"] = {
      add = { "<", ">" },
      find = function()
        return M.get_selection({ motion = "a>" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["["] = {
      add = { "[ ", " ]" },
      find = function()
        return M.get_selection({ motion = "a[" })
      end,
      delete = "^(. ?)().-( ?.)()$",
    },
    ["]"] = {
      add = { "[", "]" },
      find = function()
        return M.get_selection({ motion = "a]" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["'"] = {
      add = { "'", "'" },
      find = function()
        return M.get_selection({ motion = "a'" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ['"'] = {
      add = { '"', '"' },
      find = function()
        return M.get_selection({ motion = 'a"' })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["`"] = {
      add = { "`", "`" },
      find = function()
        return M.get_selection({ motion = "a`" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["i"] = {
      add = function()
        local left_delimiter = M.get_input("Enter the left delimiter: ")
        local right_delimiter = left_delimiter and M.get_input("Enter the right delimiter: ")
        if right_delimiter then
          return { { left_delimiter }, { right_delimiter } }
        end
      end,
      find = function() end,
      delete = function() end,
    },
    ["t"] = {
      add = function()
        local user_input = M.get_input("Enter the HTML tag: ")
        if user_input then
          local element = user_input:match("^<?([^%s>]*)")
          local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

          local open = attributes and element .. " " .. attributes or element
          local close = element

          return { { "<" .. open .. ">" }, { "</" .. close .. ">" } }
        end
      end,
      find = function()
        return M.get_selection({ motion = "at" })
      end,
      delete = "^(%b<>)().-(%b<>)()$",
      change = {
        target = "^<([^%s<>]*)().-([^/]*)()>$",
        replacement = function()
          local user_input = M.get_input("Enter the HTML tag: ")
          if user_input then
            local element = user_input:match("^<?([^%s>]*)")
            local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

            local open = attributes and element .. " " .. attributes or element
            local close = element

            return { { open }, { close } }
          end
        end,
      },
    },
    ["T"] = {
      add = function()
        local user_input = M.get_input("Enter the HTML tag: ")
        if user_input then
          local element = user_input:match("^<?([^%s>]*)")
          local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

          local open = attributes and element .. " " .. attributes or element
          local close = element

          return { { "<" .. open .. ">" }, { "</" .. close .. ">" } }
        end
      end,
      find = function()
        return M.get_selection({ motion = "at" })
      end,
      delete = "^(%b<>)().-(%b<>)()$",
      change = {
        target = "^<([^>]*)().-([^/]*)()>$",
        replacement = function()
          local user_input = M.get_input("Enter the HTML tag: ")
          if user_input then
            local element = user_input:match("^<?([^%s>]*)")
            local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

            local open = attributes and element .. " " .. attributes or element
            local close = element

            return { { open }, { close } }
          end
        end,
      },
    },
    ["f"] = {
      add = function()
        local result = M.get_input("Enter the function name: ")
        if result then
          return { { result .. "(" }, { ")" } }
        end
      end,
      find = function()
        if vim.g.loaded_nvim_treesitter then
          local selection = M.get_selection({
            query = {
              capture = "@call.outer",
              type = "textobjects",
            },
          })
          if selection then
            return selection
          end
        end
        return M.get_selection({ pattern = "[^=%s%(%){}]+%b()" })
      end,
      delete = "^(.-%()().-(%))()$",
      change = {
        target = "^.-([%w_]+)()%(.-%)()()$",
        replacement = function()
          local result = M.get_input("Enter the function name: ")
          if result then
            return { { result }, { "" } }
          end
        end,
      },
    },
    -- Tree-sitter text objects for your custom layout
    ["ro"] = {
      add = { "", "" },
      find = function()
        return M.get_selection({
          query = {
            capture = "@function.outer",
            type = "textobjects",
          },
        })
      end,
      delete = "^()(.-)()()$",
    },
    ["rr"] = {
      add = { "", "" },
      find = function()
        return M.get_selection({
          query = {
            capture = "@function.inner",
            type = "textobjects",
          },
        })
      end,
      delete = "^()(.-)()()$",
    },
    ["rw"] = {
      add = { "", "" },
      find = function()
        return M.get_selection({
          query = {
            capture = "@class.inner",
            type = "textobjects",
          },
        })
      end,
      delete = "^()(.-)()()$",
    },
    invalid_key_behavior = {
      add = function(char)
        if not char or char:find("%c") then
          return nil
        end
        return { { char }, { char } }
      end,
      find = function(char)
        if not char or char:find("%c") then
          return nil
        end
        return M.get_selection({
          pattern = vim.pesc(char) .. ".-" .. vim.pesc(char),
        })
      end,
      delete = function(char)
        if not char then
          return nil
        end
        return M.get_selections({
          char = char,
          pattern = "^(.)().-(.)()$",
        })
      end,
    },
  },
  aliases = {
    ["a"] = ">",
    ["b"] = ")",
    ["B"] = "}",
    ["q"] = { '"', "'", "`" },
    ["s"] = { "}", "]", ")", ">", '"', "'", "`" },
  },
  highlight = {
    duration = 0,
  },
  move_cursor = "begin",
  indent_lines = function(start, stop)
    local b = vim.bo
    if start < stop and (b.equalprg ~= "" or b.indentexpr ~= "" or b.cindent or b.smartindent or b.lisp) then
      vim.cmd(string.format("silent normal! %dG=%dG", start, stop))
      require("nvim-surround.cache").set_callback("")
    end
  end,
}

M.get_input = function(prompt)
  local input = require("nvim-surround.input")
  return input.get_input(prompt)
end

M.get_selection = function(args)
  if args.char then
    return M.get_find(args.char)(args.char)
  elseif args.motion then
    return require("nvim-surround.motions").get_selection(args.motion)
  elseif args.node then
    return require("nvim-surround.treesitter").get_selection(args.node)
  elseif args.pattern then
    return require("nvim-surround.patterns").get_selection(args.pattern)
  elseif args.query then
    return require("nvim-surround.queries").get_selection(args.query.capture, args.query.type)
  else
    vim.notify("Invalid key provided for `:h nvim-surround.config.get_selection()`.", vim.log.levels.ERROR)
  end
end

M.get_selections = function(args)
  local selection = M.get_selection({ char = args.char })
  if not selection then
    return nil
  end
  if args.pattern then
    return require("nvim-surround.patterns").get_selections(selection, args.pattern)
  else
    vim.notify("Invalid key provided for `:h nvim-surround.config.get_selections()`.", vim.log.levels.ERROR)
  end
end

return {
  "kylechui/nvim-surround",
  version = "^3.0.0",
  event = "VeryLazy",
  config = function()
    require("nvim-surround").setup(M.default_opts)
  end,
}

=== ./lua/plugins/gitlinker.lua ===
return {
  "ruifm/gitlinker.nvim",
  dependencies = "nvim-lua/plenary.nvim",
  opts = {},
  keys = {
    { "<leader>gy", desc = "Copy git link" },
  },
}
=== ./lua/plugins/comment (yuval-rz's conflicted copy 2025-06-11).lua ===
return {
  {
    "numToStr/Comment.nvim",
    opts = function()
      return {
        pre_hook = function(ctx)
          local U = require('Comment.utils')
          
          -- Determine whether to use linewise or blockwise commentstring
          local type = ctx.ctype == U.ctype.linewise and '__default' or '__multiline'
          
          -- Determine the location where to calculate commentstring from
          local location = nil
          if ctx.ctype == U.ctype.blockwise then
            location = require('ts_context_commentstring.utils').get_cursor_location()
          elseif ctx.cmotion == U.cmotion.v or ctx.cmotion == U.cmotion.V then
            location = require('ts_context_commentstring.utils').get_visual_start_location()
          end
          
          return require('ts_context_commentstring.internal').calculate_commentstring({
            key = type,
            location = location,
          })
        end,
      }
    end,
    dependencies = {
      "JoosepAlviste/nvim-ts-context-commentstring",
    },
    lazy = false,
  },
}

=== ./lua/plugins/conform.lua ===
return {
  "stevearc/conform.nvim",
  opts = {
    formatters_by_ft = {
      typescript = { "biome" },
      javascript = { "biome" },
      typescriptreact = { "biome" },
      javascriptreact = { "biome" },
      json = { "biome" },
    },
    -- Enable format on save
    -- format_on_save = {
    -- timeout_ms = 500,
    -- lsp_fallback = true,
    -- },
  },
}

=== ./lua/plugins/gitsigns.lua ===
return {
  "lewis6991/gitsigns.nvim",
  event = "BufReadPre",
  opts = function()
    return {
      on_attach = function(buffer)
        local gs = package.loaded.gitsigns

        local function map(mode, l, r, desc)
          vim.keymap.set(mode, l, r, { buffer = buffer, desc = desc })
        end

        -- Navigation adapted for HAEI layout (]e = next, [e = prev)
        map("n", "]e", gs.next_hunk, "Next Hunk")
        map("n", "[e", gs.prev_hunk, "Prev Hunk")
        
        -- Stage/reset hunks
        map({ "n", "v" }, "<leader>gg", ":Gitsigns stage_hunk<CR>", "Stage Hunk")
        map({ "n", "v" }, "<leader>gx", ":Gitsigns reset_hunk<CR>", "Reset Hunk")
        
        -- Buffer operations
        map("n", "<leader>gG", gs.stage_buffer, "Stage Buffer")
        map("n", "<leader>gu", gs.undo_stage_hunk, "Undo Stage Hunk")
        map("n", "<leader>gX", gs.reset_buffer, "Reset Buffer")
        
        -- Preview and blame
        map("n", "<leader>gp", gs.preview_hunk, "Preview Hunk")
        map("n", "<leader>gb", function()
          gs.blame_line({ full = true })
        end, "Blame Line")
        
        -- Diff operations
        map("n", "<leader>gd", gs.diffthis, "Diff This")
        map("n", "<leader>gD", function()
          gs.diffthis("~")
        end, "Diff This ~")
        
        -- Text object for hunks
        map({ "o", "x" }, "ih", ":<C-U>Gitsigns select_hunk<CR>", "GitSigns Select Hunk")
      end,
    }
  end,
}
=== ./lua/plugins/barbar.lua ===
return {
  "romgrk/barbar.nvim",
  dependencies = {
    "lewis6991/gitsigns.nvim", -- OPTIONAL: for git status
    "nvim-tree/nvim-web-devicons", -- OPTIONAL: for file icons
  },
  init = function()
    vim.g.barbar_auto_setup = false
  end,
  opts = {
    -- lazy.nvim will automatically call setup for you. put your options here, anything missing will use the default:
    -- animation = true,
    -- insert_at_start = true,
    -- …etc.
  },
  version = "^1.0.0", -- optional: only update when a new 1.x version is released
}

=== ./lua/plugins/dash.lua ===
return {
  "johnseth97/gh-dash.nvim",
  lazy = true,
  cmd = { "GHdash", "GHdashToggle" },
  keys = {
    { "<leader>gh", function() require('gh_dash').toggle() end, desc = "GitHub Dashboard" },
  },
  opts = {
    keymaps = {},
    border = 'rounded',
    width = 0.8,
    height = 0.8,
    autoinstall = true,
  },
}

=== ./lua/plugins/treesitter.lua ===
-- Use default ] and [ for treesitter navigation
local next_key = "]"
local prev_key = "["

return {
  "nvim-treesitter/nvim-treesitter-textobjects",
  opts = {
    textobjects = {
      move = {
        enable = true,
        set_jumps = true,
        goto_next_start = {
          [next_key .. "m"] = "@function.outer",
          [next_key .. "c"] = "@class.outer",
          [next_key .. "a"] = "@parameter.inner",
          [next_key .. "o"] = "@loop.*",
          [next_key .. "s"] = "@scope",
          [next_key .. "z"] = "@fold",
          [next_key .. next_key] = "@class.outer",
        },
        goto_next_end = {
          [next_key .. "M"] = "@function.outer",
          [next_key .. prev_key] = "@class.outer",
        },
        goto_previous_start = {
          [prev_key .. "m"] = "@function.outer",
          [prev_key .. "c"] = "@class.outer",
          [prev_key .. "a"] = "@parameter.inner",
          [prev_key .. "o"] = "@loop.*",
          [prev_key .. "s"] = "@scope",
          [prev_key .. "z"] = "@fold",
          [prev_key .. prev_key] = "@class.outer",
        },
        goto_previous_end = {
          [prev_key .. "M"] = "@function.outer",
          [prev_key .. next_key] = "@class.outer",
        },
      },
      select = {
        enable = true,
        keymaps = {
          -- Using your HAEI layout: r=inner, t=around
          ["tf"] = "@function.outer",
          ["rf"] = "@function.inner",
          ["tc"] = "@class.outer",
          ["rc"] = "@class.inner",
          ["tp"] = "@parameter.outer",
          ["rp"] = "@parameter.inner",
          ["to"] = "@loop.outer",
          ["ro"] = "@loop.inner",
          ["ts"] = "@scope",
          ["rs"] = "@scope",
          -- JSX/HTML elements - automatically available to surround
          ["ty"] = "@element.outer",
          ["ry"] = "@element.inner",
        },
      },
      swap = {
        enable = true,
        swap_next = {
          [next_key .. "A"] = "@parameter.inner",
          [next_key .. "F"] = "@function.outer",
        },
        swap_previous = {
          [prev_key .. "A"] = "@parameter.inner",
          [prev_key .. "F"] = "@function.outer",
        },
      },
    },
  },
}

=== ./lua/plugins/emmet.lua ===
return {
  "mattn/emmet-vim",
  ft = { "html", "css", "javascript", "typescript", "javascriptreact", "typescriptreact", "vue", "svelte" },
  config = function()
    -- Use standard Ctrl+y, key binding (community convention)
    vim.g.user_emmet_leader_key = "<C-y>"
    vim.g.user_emmet_mode = "i"
    
    -- Enable emmet for JSX/TSX
    vim.g.user_emmet_settings = {
      javascript = {
        extends = "jsx",
      },
      typescript = {
        extends = "jsx",
      },
    }
  end,
}
=== ./lua/plugins/toggle-boolean.lua ===
return {
  -- Simple boolean/value toggler
  {
    "rmagatti/alternate-toggler",
    event = { "BufReadPost" },
    config = function()
      require("alternate-toggler").setup({
        alternates = {
          ["true"] = "false",
          ["True"] = "False",
          ["TRUE"] = "FALSE",
          ["yes"] = "no",
          ["Yes"] = "No",
          ["YES"] = "NO",
          ["1"] = "0",
          ["on"] = "off",
          ["On"] = "Off",
          ["ON"] = "OFF",
          ["enable"] = "disable",
          ["Enable"] = "Disable",
          ["ENABLE"] = "DISABLE",
          ["enabled"] = "disabled",
          ["Enabled"] = "Disabled",
          ["ENABLED"] = "DISABLED",
          ["&&"] = "||",
          ["and"] = "or",
          ["And"] = "Or",
          ["AND"] = "OR",
          ["left"] = "right",
          ["Left"] = "Right",
          ["LEFT"] = "RIGHT",
          ["up"] = "down",
          ["Up"] = "Down",
          ["UP"] = "DOWN",
          ["public"] = "private",
          ["Public"] = "Private",
          ["PUBLIC"] = "PRIVATE",
          ["const"] = "let",
          ["width"] = "height",
          ["Width"] = "Height",
          ["WIDTH"] = "HEIGHT",
          ["horizontal"] = "vertical",
          ["Horizontal"] = "Vertical",
          ["HORIZONTAL"] = "VERTICAL",
        },
      })
    end,
    keys = {
      { "<C-t>", "<cmd>ToggleAlternate<cr>", desc = "Toggle alternate" },
    },
  },
}

=== ./lua/plugins/lsp.lua ===
return {
  -- LSP Configuration & Plugins
  {
    "neovim/nvim-lspconfig",
    dependencies = {
      "mason.nvim",
      "mason-lspconfig.nvim",
    },
  },

  -- Mason for managing LSP servers
  {
    "williamboman/mason.nvim",
    cmd = "Mason",
    keys = { { "<leader>cm", "<cmd>Mason<cr>", desc = "Mason" } },
    opts = {
      ensure_installed = {
        "stylua",
        "shfmt",
        -- Add any other tools you want installed
      },
    },
  },

  -- Bridge between Mason and lspconfig
  {
    "williamboman/mason-lspconfig.nvim",
    opts = {
      ensure_installed = {
        "lua_ls",
        "ts_ls", -- Keep for installation but don't setup
        -- Add any language servers you want installed
      },
      automatic_installation = true,
      handlers = {
        -- Default setup for all servers
        function(server_name)
          require('lspconfig')[server_name].setup({})
        end,
        -- Prevent typescript-language-server setup (managed by typescript-tools)
        ['ts_ls'] = function()
          -- do nothing, managed by typescript-tools
        end,
        ['tsserver'] = function()
          -- do nothing, managed by typescript-tools (for older lspconfig)
        end,
      },
    },
  },

  -- TypeScript type information display
  {
    "marilari88/twoslash-queries.nvim",
    ft = { "typescript", "typescriptreact", "javascript", "javascriptreact" },
    opts = {
      multi_line = true,
      is_enabled = true,
    },
  },

  -- Enhanced TypeScript development
  {
    "pmizio/typescript-tools.nvim",
    ft = { "typescript", "typescriptreact", "javascript", "javascriptreact" },
    dependencies = { "nvim-lua/plenary.nvim", "neovim/nvim-lspconfig" },
    keys = {
      { "<leader>cI", "<cmd>TSToolsAddMissingImports<cr>", desc = "Add missing imports", ft = { "typescript", "typescriptreact", "javascript", "javascriptreact" } },
      { "<leader>ci", function() vim.lsp.buf.code_action({ apply = true, filter = function(action) return action.title:match("Add import") or action.title:match("Import") end }) end, desc = "Import symbol under cursor", ft = { "typescript", "typescriptreact", "javascript", "javascriptreact" } },
    },
    opts = {
      on_attach = function(client, bufnr)
        -- Enable inlay hints for TypeScript
        if client.supports_method("textDocument/inlayHint") then
          vim.lsp.inlay_hint.enable(true, { bufnr = bufnr })
        end
      end,
      handlers = {
        ["workspace/executeCommand"] = function(_err, result, ctx, _config)
          if ctx.params.command ~= "_typescript.goToSourceDefinition" then
            return
          end
          if result == nil or #result == 0 then
            return
          end
          vim.lsp.util.jump_to_location(result[1], "utf-8")
        end,
      },
      settings = {
        typescript = {
          inlayHints = {
            includeInlayParameterNameHints = "all",
            includeInlayParameterNameHintsWhenArgumentMatchesName = false,
            includeInlayFunctionParameterTypeHints = true,
            includeInlayVariableTypeHints = true,
            includeInlayPropertyDeclarationTypeHints = true,
            includeInlayFunctionLikeReturnTypeHints = true,
            includeInlayEnumMemberValueHints = true,
          },
          preferences = {
            includePackageJsonAutoImports = "auto",
            importModuleSpecifier = "non-relative",
            includeCompletionsForModuleExports = true,
            includeCompletionsForImportStatements = true,
          },
          validate = { enable = true },
          suggest = {
            includeCompletionsForModuleExports = true,
          },
        },
        javascript = {
          inlayHints = {
            includeInlayParameterNameHints = "all",
            includeInlayParameterNameHintsWhenArgumentMatchesName = false,
            includeInlayFunctionParameterTypeHints = true,
            includeInlayVariableTypeHints = true,
            includeInlayPropertyDeclarationTypeHints = true,
            includeInlayFunctionLikeReturnTypeHints = true,
            includeInlayEnumMemberValueHints = true,
          },
        },
      },
    },
  },
}

=== ./lua/plugins/tabout.lua ===
-- Lua
return {
  {
    "abecodes/tabout.nvim",
    lazy = false,
    config = function()
      require("tabout").setup({
        tabkey = "<Tab>", -- key to trigger tabout, set to an empty string to disable
        backwards_tabkey = "<S-Tab>", -- key to trigger backwards tabout, set to an empty string to disable
        act_as_tab = true, -- shift content if tab out is not possible
        act_as_shift_tab = false, -- reverse shift content if tab out is not possible (if your keyboard/terminal supports <S-Tab>)
        default_tab = "<C-t>", -- shift default action (only at the beginning of a line, otherwise <TAB> is used)
        default_shift_tab = "<C-d>", -- reverse shift default action,
        enable_backwards = true, -- well ...
        completion = false, -- if the tabkey is used in a completion pum
        tabouts = {
          { open = "'", close = "'" },
          { open = '"', close = '"' },
          { open = "`", close = "`" },
          { open = "(", close = ")" },
          { open = "[", close = "]" },
          { open = "{", close = "}" },
        },
        ignore_beginning = true, --[[ if the cursor is at the beginning of a filled element it will rather tab out than shift the content ]]
        exclude = {}, -- tabout will ignore these filetypes
      })
    end,
    dependencies = { -- These are optional
      "nvim-treesitter/nvim-treesitter",
      "L3MON4D3/LuaSnip",
      "hrsh7th/nvim-cmp",
    },
    opt = true, -- Set this to true if the plugin is optional
    event = "InsertCharPre", -- Set the event to 'InsertCharPre' for better compatibility
    priority = 1000,
  },
  {
    "L3MON4D3/LuaSnip",
    keys = function()
      -- Disable default tab keybinding in LuaSnip
      return {}
    end,
  },
}

=== ./lua/plugins/move.lua ===
return {
  "fedepujol/move.nvim",
  keys = {
    -- Normal Mode (using Graphite layout: a=down, e=up)
    { "<M-a>", ":MoveLine(1)<CR>", desc = "Move Line Down" },
    { "<M-e>", ":MoveLine(-1)<CR>", desc = "Move Line Up" },
    { "<M-h>", ":MoveHChar(-1)<CR>", desc = "Move Character Left" },
    { "<M-i>", ":MoveHChar(1)<CR>", desc = "Move Character Right" },
    { "<leader>wf", ":MoveWord(1)<CR>", mode = { "n" }, desc = "Move Word Forward" },
    { "<leader>wb", ":MoveWord(-1)<CR>", mode = { "n" }, desc = "Move Word Backward" },
    -- Visual Mode
    { "<M-a>", ":MoveBlock(1)<CR>", mode = { "v" }, desc = "Move Block Down" },
    { "<M-e>", ":MoveBlock(-1)<CR>", mode = { "v" }, desc = "Move Block Up" },
    { "<M-h>", ":MoveHBlock(-1)<CR>", mode = { "v" }, desc = "Move Block Left" },
    { "<M-i>", ":MoveHBlock(1)<CR>", mode = { "v" }, desc = "Move Block Right" },
  },
  opts = {
    line = {
      enable = true,
      indent = true
    },
    block = {
      enable = true,
      indent = true
    },
    word = {
      enable = true,
    },
    char = {
      enable = true
    }
  }
}
=== ./init.lua ===
require("config.lazy")

