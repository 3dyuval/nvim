#!/usr/bin/env bash

# Batch Formatter - Sandboxed conform.nvim formatter
# Uses a minimal neovim setup with only conform.nvim loaded to avoid config conflicts
# This provides a clean environment for batch formatting operations

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

# Create minimal init.lua for formatting
create_minimal_init() {
    local temp_init=$(mktemp --suffix=.lua)
    cat > "$temp_init" << 'EOF'
-- Minimal init.lua for formatting only
local lazy_path = vim.fn.stdpath('data') .. '/lazy/conform.nvim'
if not vim.loop.fs_stat(lazy_path) then
  print('ERROR: conform.nvim not found at ' .. lazy_path)
  os.exit(1)
end

vim.opt.rtp:prepend(lazy_path)

-- Only load conform.nvim with minimal config
require('conform').setup({
  formatters_by_ft = {
    javascript = { 'biome' },
    javascriptreact = { 'biome' },
    typescript = { 'biome' },
    typescriptreact = { 'biome' },
    json = { 'biome' },
    lua = { 'stylua' },
    html = { 'prettier' },
    vue = { 'prettier' },
  },
  formatters = {
    biome = {
      args = {
        'format',
        '--config-path',
        vim.fn.expand('~/.config/nvim/biome.json'),
        '--stdin-file-path',
        '$FILENAME',
      },
    },
  },
})

-- Format function
function FormatFile(filepath)
  if vim.fn.filereadable(filepath) == 0 then
    print('ERROR: File not found: ' .. filepath)
    os.exit(1)
  end
  
  local bufnr = vim.fn.bufnr(filepath, true)
  vim.fn.bufload(bufnr)
  
  -- Set filetype based on extension
  local ext = filepath:match('%.(%w+)$')
  if ext == 'js' then vim.bo[bufnr].filetype = 'javascript'
  elseif ext == 'jsx' then vim.bo[bufnr].filetype = 'javascriptreact'
  elseif ext == 'ts' then vim.bo[bufnr].filetype = 'typescript'
  elseif ext == 'tsx' then vim.bo[bufnr].filetype = 'typescriptreact'
  elseif ext == 'json' then vim.bo[bufnr].filetype = 'json'
  elseif ext == 'lua' then vim.bo[bufnr].filetype = 'lua'
  elseif ext == 'html' then vim.bo[bufnr].filetype = 'html'
  elseif ext == 'vue' then vim.bo[bufnr].filetype = 'vue'
  end
  
  local conform = require('conform')
  local formatters = conform.list_formatters(bufnr)
  
  if #formatters == 0 then
    print('INFO: No formatters configured for ' .. filepath)
    os.exit(0)
  end
  
  local success = conform.format({ bufnr = bufnr, timeout_ms = 5000 })
  
  if success then
    vim.api.nvim_buf_call(bufnr, function()
      vim.cmd('silent! write!')
    end)
    print('SUCCESS: Formatted ' .. filepath)
  else
    print('ERROR: Failed to format ' .. filepath)
    os.exit(1)
  end
end
EOF
    echo "$temp_init"
}

# Format a single file
format_file() {
    local file="$1"
    local temp_init="$2"
    
    if [[ ! -f "$file" ]]; then
        log_error "File not found: $file"
        return 1
    fi
    
    # Run neovim with minimal config
    local result
    result=$(nvim --headless -u "$temp_init" -c "lua FormatFile('$file')" -c "qall" 2>&1)
    
    if [[ "$result" == "SUCCESS:"* ]]; then
        log_info "$(echo "$result" | sed 's/SUCCESS: //')"
        return 0
    elif [[ "$result" == "INFO:"* ]]; then
        # Not an error, just no formatters
        return 0
    else
        log_error "$(echo "$result" | sed 's/ERROR: //')"
        return 1
    fi
}

# Process directory
process_directory() {
    local dir="$1"
    local temp_init="$2"
    
    # Find supported files
    local files=()
    while IFS= read -r -d '' file; do
        files+=("$file")
    done < <(find "$dir" -type f \( -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" -o -name "*.json" -o -name "*.lua" -o -name "*.html" -o -name "*.vue" \) -print0)
    
    if [[ ${#files[@]} -eq 0 ]]; then
        log_info "No supported files found in $dir"
        return 0
    fi
    
    log_info "Found ${#files[@]} files in $dir"
    
    local success=0
    for file in "${files[@]}"; do
        if format_file "$file" "$temp_init"; then
            ((success++))
        fi
    done
    
    log_info "Processed $success/${#files[@]} files"
    return $([[ $success -eq ${#files[@]} ]] && echo 0 || echo 1)
}

# Main function
main() {
    local targets=()
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                cat << EOF
Usage: $0 [files or directories...]

Sandboxed formatter using conform.nvim in minimal neovim environment.
This avoids loading your full neovim configuration.

Examples:
  $0 file.js file.ts    # Format specific files
  $0 src/               # Format all supported files in directory
  $0 .                  # Format current directory
EOF
                exit 0
                ;;
            *)
                targets+=("$1")
                shift
                ;;
        esac
    done
    
    # Default to current directory
    if [[ ${#targets[@]} -eq 0 ]]; then
        targets=(".")
    fi
    
    # Check dependencies
    if ! command -v nvim &> /dev/null; then
        log_error "Neovim is required"
        exit 1
    fi
    
    # Create minimal init file
    local temp_init
    temp_init=$(create_minimal_init)
    
    # Ensure cleanup
    trap "rm -f '$temp_init'" EXIT
    
    local exit_code=0
    
    # Process each target
    for target in "${targets[@]}"; do
        if [[ -f "$target" ]]; then
            if ! format_file "$target" "$temp_init"; then
                exit_code=1
            fi
        elif [[ -d "$target" ]]; then
            if ! process_directory "$target" "$temp_init"; then
                exit_code=1
            fi
        else
            log_error "File or directory not found: $target"
            exit_code=1
        fi
    done
    
    exit $exit_code
}

main "$@"