#!/usr/bin/env bash

# Batch formatting integration script
# Uses existing Neovim configuration files for consistent code styling

set -euo pipefail

# Configuration
ROOT_DIR="${ROOT_DIR:-$HOME/.config/nvim}"
BIOME_CONFIG="$ROOT_DIR/biome.json"
PRETTIER_CONFIG="$ROOT_DIR/.prettierrc"
LUACHECK_CONFIG="$ROOT_DIR/.luacheck"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Print usage information
usage() {
    cat << EOF
Usage: $0 [OPTIONS] [FILE|DIRECTORY...]

Batch formatter using Neovim configuration files for consistent styling.

OPTIONS:
    -h, --help          Show this help message
    -v, --verbose       Enable verbose output
    -c, --check         Check formatting without making changes
    -d, --dry-run       Show what would be formatted without doing it
    
ENVIRONMENT:
    ROOT_DIR            Directory containing formatter configs (default: ~/.config/nvim)
    
EXAMPLES:
    $0 src/                     # Format all files in src directory
    $0 file1.js file2.ts        # Format specific files
    $0 --check .                # Check formatting for current directory
    $0 -v **/*.{js,ts,lua}      # Format with verbose output using glob

SUPPORTED FILE TYPES:
    JavaScript/TypeScript: .js, .jsx, .ts, .tsx (via Biome → Prettier fallback)
    JSON: .json (via Biome → Prettier fallback)
    Lua: .lua (via stylua)
    
CONFIGURATION FILES:
    Biome: $BIOME_CONFIG
    Prettier: $PRETTIER_CONFIG
    Luacheck: $LUACHECK_CONFIG
EOF
}

# Logging functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_verbose() {
    if [[ "${VERBOSE:-0}" == "1" ]]; then
        echo -e "${YELLOW}[VERBOSE]${NC} $1"
    fi
}

# Check if required tools are available
check_dependencies() {
    local missing=()
    
    if ! command -v biome &> /dev/null; then
        missing+=("biome")
    fi
    
    if ! command -v prettier &> /dev/null; then
        missing+=("prettier")
    fi
    
    if ! command -v stylua &> /dev/null; then
        missing+=("stylua")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing required tools: ${missing[*]}"
        log_error "Install with: npm install -g @biomejs/biome prettier"
        log_error "Install stylua from: https://github.com/JohnnyMorganz/StyLua"
        exit 1
    fi
}

# Check if config files exist
check_configs() {
    if [[ ! -f "$BIOME_CONFIG" ]]; then
        log_warn "Biome config not found at $BIOME_CONFIG"
    fi
    
    if [[ ! -f "$PRETTIER_CONFIG" ]]; then
        log_warn "Prettier config not found at $PRETTIER_CONFIG"
    fi
    
    if [[ ! -f "$LUACHECK_CONFIG" ]]; then
        log_warn "Luacheck config not found at $LUACHECK_CONFIG"
    fi
}

# Get file extension
get_extension() {
    local file="$1"
    echo "${file##*.}"
}

# Format a single file
format_file() {
    local file="$1"
    local ext
    ext=$(get_extension "$file")
    
    if [[ ! -f "$file" ]]; then
        log_error "File not found: $file"
        return 1
    fi
    
    log_verbose "Processing file: $file (extension: $ext)"
    
    case "$ext" in
        js|jsx|ts|tsx|json)
            format_js_ts_json "$file"
            ;;
        lua)
            format_lua "$file"
            ;;
        *)
            log_warn "Unsupported file type: $file"
            return 1
            ;;
    esac
}

# Format JavaScript/TypeScript/JSON files
format_js_ts_json() {
    local file="$1"
    local temp_file="${file}.tmp"
    local abs_file
    abs_file=$(realpath "$file")
    
    # Try Biome first (format + organize imports + lint fixes)
    if [[ -f "$BIOME_CONFIG" ]]; then
        # Use biome check --write which runs format + organize imports + lint fixes
        if (cd "$ROOT_DIR" && biome check --write "$abs_file" 2>/dev/null); then
            log_verbose "Formatted and organized imports in $file with Biome"
            return 0
        fi
    fi
    
    # Fall back to Prettier
    if [[ -f "$PRETTIER_CONFIG" ]]; then
        if prettier --config "$PRETTIER_CONFIG" --write "$file" 2>/dev/null; then
            log_verbose "Formatted $file with Prettier"
            return 0
        fi
    else
        # Use prettier without config
        if prettier --write "$file" 2>/dev/null; then
            log_verbose "Formatted $file with Prettier (no config)"
            return 0
        fi
    fi
    
    log_error "Failed to format $file"
    return 1
}

# Format Lua files
format_lua() {
    local file="$1"
    local stylua_config="$ROOT_DIR/stylua.toml"
    
    if [[ -f "$stylua_config" ]]; then
        if stylua --config-path "$stylua_config" "$file" 2>/dev/null; then
            log_verbose "Formatted $file with stylua"
            return 0
        fi
    else
        # Try without config
        if stylua "$file" 2>/dev/null; then
            log_verbose "Formatted $file with stylua (no config)"
            return 0
        fi
    fi
    
    log_error "Failed to format $file with stylua"
    return 1
}

# Check formatting without making changes
check_file() {
    local file="$1"
    local ext
    ext=$(get_extension "$file")
    
    case "$ext" in
        js|jsx|ts|tsx|json)
            check_js_ts_json "$file"
            ;;
        lua)
            check_lua "$file"
            ;;
        *)
            log_warn "Unsupported file type for checking: $file"
            return 1
            ;;
    esac
}

# Check JavaScript/TypeScript/JSON files
check_js_ts_json() {
    local file="$1"
    local abs_file
    abs_file=$(realpath "$file")
    
    # Try Biome first
    if [[ -f "$BIOME_CONFIG" ]]; then
        if (cd "$ROOT_DIR" && biome check "$abs_file" &>/dev/null); then
            return 0
        fi
    fi
    
    # Fall back to Prettier
    if [[ -f "$PRETTIER_CONFIG" ]]; then
        if prettier --config "$PRETTIER_CONFIG" --check "$file" &>/dev/null; then
            return 0
        fi
    else
        if prettier --check "$file" &>/dev/null; then
            return 0
        fi
    fi
    
    return 1
}

# Check Lua files
check_lua() {
    local file="$1"
    local stylua_config="$ROOT_DIR/stylua.toml"
    
    if [[ -f "$stylua_config" ]]; then
        if stylua --config-path "$stylua_config" --check "$file" &>/dev/null; then
            return 0
        fi
    else
        if stylua --check "$file" &>/dev/null; then
            return 0
        fi
    fi
    
    return 1
}

# Process directory recursively
process_directory() {
    local dir="$1"
    local found_files=()
    
    # Find supported files
    while IFS= read -r -d '' file; do
        found_files+=("$file")
    done < <(find "$dir" -type f \( -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" -o -name "*.json" -o -name "*.lua" \) -print0)
    
    if [[ ${#found_files[@]} -eq 0 ]]; then
        log_warn "No supported files found in $dir"
        return 0
    fi
    
    log_info "Found ${#found_files[@]} files in $dir"
    
    local success=0
    local total=${#found_files[@]}
    
    for file in "${found_files[@]}"; do
        if [[ "$CHECK_ONLY" == "1" ]]; then
            if check_file "$file"; then
                ((success++))
            else
                log_error "File needs formatting: $file"
            fi
        elif [[ "$DRY_RUN" == "1" ]]; then
            echo "Would format: $file"
            ((success++))
        else
            if format_file "$file"; then
                ((success++))
            fi
        fi
    done
    
    log_info "Processed $success/$total files successfully"
    
    if [[ "$success" -ne "$total" ]]; then
        return 1
    fi
}

# Main function
main() {
    local files=()
    local CHECK_ONLY=0
    local DRY_RUN=0
    local VERBOSE=0
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -c|--check)
                CHECK_ONLY=1
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=1
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                usage
                exit 1
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done
    
    # If no files specified, use current directory
    if [[ ${#files[@]} -eq 0 ]]; then
        files=(".")
    fi
    
    # Export variables for use in functions
    export VERBOSE CHECK_ONLY DRY_RUN
    
    # Check dependencies and configs
    check_dependencies
    check_configs
    
    log_info "Using ROOT_DIR: $ROOT_DIR"
    
    local exit_code=0
    
    # Process each file/directory
    for target in "${files[@]}"; do
        if [[ -f "$target" ]]; then
            if [[ "$CHECK_ONLY" == "1" ]]; then
                if ! check_file "$target"; then
                    log_error "File needs formatting: $target"
                    exit_code=1
                fi
            elif [[ "$DRY_RUN" == "1" ]]; then
                echo "Would format: $target"
            else
                if ! format_file "$target"; then
                    exit_code=1
                fi
            fi
        elif [[ -d "$target" ]]; then
            if ! process_directory "$target"; then
                exit_code=1
            fi
        else
            log_error "File or directory not found: $target"
            exit_code=1
        fi
    done
    
    if [[ "$exit_code" -eq 0 ]]; then
        log_info "All files processed successfully"
    else
        log_error "Some files failed to process"
    fi
    
    exit $exit_code
}

# Run main function
main "$@"