-- Use default ] and [ for treesitter navigation
local next_key = "]"
local prev_key = "["

return {
  "nvim-treesitter/nvim-treesitter-textobjects",
  opts = {
    textobjects = {
      move = {
        enable = true,
        set_jumps = true,
        goto_next_start = {
          [next_key .. "m"] = "@function.outer",
          [next_key .. "c"] = "@class.outer",
          [next_key .. "a"] = "@parameter.inner",
          [next_key .. "o"] = "@loop.*",
          [next_key .. "s"] = "@scope",
          [next_key .. "z"] = "@fold",
          [next_key .. next_key] = "@class.outer",
        },
        goto_next_end = {
          [next_key .. "M"] = "@function.outer",
          [next_key .. prev_key] = "@class.outer",
        },
        goto_previous_start = {
          [prev_key .. "m"] = "@function.outer",
          [prev_key .. "c"] = "@class.outer",
          [prev_key .. "a"] = "@parameter.inner",
          [prev_key .. "o"] = "@loop.*",
          [prev_key .. "s"] = "@scope",
          [prev_key .. "z"] = "@fold",
          [prev_key .. prev_key] = "@class.outer",
        },
        goto_previous_end = {
          [prev_key .. "M"] = "@function.outer",
          [prev_key .. next_key] = "@class.outer",
        },
      },
      select = {
        enable = true,
        keymaps = {
          -- Using capitals to avoid conflicts with mode-specific t/r mappings
          -- These are automatically available to nvim-surround
          ["Tf"] = "@function.outer",
          ["rf"] = "@function.inner", 
          ["Tc"] = "@class.outer",
          ["rc"] = "@class.inner",
          ["Tp"] = "@parameter.outer",
          ["rp"] = "@parameter.inner",
          ["To"] = "@loop.outer",
          ["ro"] = "@loop.inner",
          ["Ts"] = "@scope",
          ["rs"] = "@scope",
          -- JSX/HTML elements
          ["Ty"] = "@element.outer",
          ["ry"] = "@element.inner",
        },
      },
      swap = {
        enable = true,
        swap_next = {
          [next_key .. "A"] = "@parameter.inner",
          [next_key .. "F"] = "@function.outer",
        },
        swap_previous = {
          [prev_key .. "A"] = "@parameter.inner",
          [prev_key .. "F"] = "@function.outer",
        },
      },
    },
  },
}
local M = {}

---@type user_options
M.default_opts = {
  keymaps = {
    insert = "<C-g>s",
    insert_line = "<C-g>S",
    normal = "ys",
    normal_cur = "yss",
    normal_line = "yS",
    normal_cur_line = "ySS",
    visual = "s",
    visual_line = "gS",
    delete = "xs",
    change = "cs",
    change_line = "cS",
  },
  surrounds = {
    ["("] = {
      add = { "( ", " )" },
      find = function()
        return M.get_selection({ motion = "a(" })
      end,
      delete = "^(. ?)().-( ?.)()$",
    },
    [")"] = {
      add = { "(", ")" },
      find = function()
        return M.get_selection({ motion = "a)" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["{"] = {
      add = { "{ ", " }" },
      find = function()
        return M.get_selection({ motion = "a{" })
      end,
      delete = "^(. ?)().-( ?.)()$",
    },
    ["}"] = {
      add = { "{", "}" },
      find = function()
        return M.get_selection({ motion = "a}" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["<"] = {
      add = { "< ", " >" },
      find = function()
        return M.get_selection({ motion = "a<" })
      end,
      delete = "^(. ?)().-( ?.)()$",
    },
    [">"] = {
      add = { "<", ">" },
      find = function()
        return M.get_selection({ motion = "a>" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["["] = {
      add = function()
        -- Check if we're in an Angular HTML file
        if vim.bo.filetype == "htmlangular" then
          return { "[", "]" }
        else
          return { "[ ", " ]" }
        end
      end,
      find = function()
        return M.get_selection({ motion = "a[" })
      end,
      delete = "^(. ?)().-( ?.)()$",
    },
    ["]"] = {
      add = { "[", "]" },
      find = function()
        return M.get_selection({ motion = "a]" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["'"] = {
      add = { "'", "'" },
      find = function()
        return M.get_selection({ motion = "a'" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ['"'] = {
      add = { '"', '"' },
      find = function()
        return M.get_selection({ motion = 'a"' })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["`"] = {
      add = { "`", "`" },
      find = function()
        return M.get_selection({ motion = "a`" })
      end,
      delete = "^(.)().-(.)()$",
    },
    ["i"] = {
      add = function()
        local left_delimiter = M.get_input("Enter the left delimiter: ")
        local right_delimiter = left_delimiter and M.get_input("Enter the right delimiter: ")
        if right_delimiter then
          return { { left_delimiter }, { right_delimiter } }
        end
      end,
      find = function() end,
      delete = function() end,
    },
    ["t"] = {
      add = function()
        local user_input = M.get_input("Enter the HTML tag: ")
        if user_input then
          local element = user_input:match("^<?([^%s>]*)")
          local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

          local open = attributes and element .. " " .. attributes or element
          local close = element

          return { { "<" .. open .. ">" }, { "</" .. close .. ">" } }
        end
      end,
      find = function()
        return M.get_selection({ motion = "at" })
      end,
      delete = "^(%b<>)().-(%b<>)()$",
      change = {
        target = "^<([^%s<>]*)().-([^/]*)()>$",
        replacement = function()
          local user_input = M.get_input("Enter the HTML tag: ")
          if user_input then
            local element = user_input:match("^<?([^%s>]*)")
            local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

            local open = attributes and element .. " " .. attributes or element
            local close = element

            return { { open }, { close } }
          end
        end,
      },
    },
    ["T"] = {
      add = function()
        local user_input = M.get_input("Enter the HTML tag: ")
        if user_input then
          local element = user_input:match("^<?([^%s>]*)")
          local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

          local open = attributes and element .. " " .. attributes or element
          local close = element

          return { { "<" .. open .. ">" }, { "</" .. close .. ">" } }
        end
      end,
      find = function()
        return M.get_selection({ motion = "at" })
      end,
      delete = "^(%b<>)().-(%b<>)()$",
      change = {
        target = "^<([^>]*)().-([^/]*)()>$",
        replacement = function()
          local user_input = M.get_input("Enter the HTML tag: ")
          if user_input then
            local element = user_input:match("^<?([^%s>]*)")
            local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

            local open = attributes and element .. " " .. attributes or element
            local close = element

            return { { open }, { close } }
          end
        end,
      },
    },
    ["f"] = {
      add = function()
        local result = M.get_input("Enter the function name: ")
        if result then
          return { { result .. "(" }, { ")" } }
        end
      end,
      find = function()
        if vim.g.loaded_nvim_treesitter then
          local selection = M.get_selection({
            query = {
              capture = "@call.outer",
              type = "textobjects",
            },
          })
          if selection then
            return selection
          end
        end
        return M.get_selection({ pattern = "[^=%s%(%){}]+%b()" })
      end,
      delete = "^(.-%()().-(%))()$",
      change = {
        target = "^.-([%w_]+)()%(.-%)()()$",
        replacement = function()
          local result = M.get_input("Enter the function name: ")
          if result then
            return { { result }, { "" } }
          end
        end,
      },
    },
    invalid_key_behavior = {
      add = function(char)
        if not char or char:find("%c") then
          return nil
        end
        return { { char }, { char } }
      end,
      find = function(char)
        if not char or char:find("%c") then
          return nil
        end
        return M.get_selection({
          pattern = vim.pesc(char) .. ".-" .. vim.pesc(char),
        })
      end,
      delete = function(char)
        if not char then
          return nil
        end
        return M.get_selections({
          char = char,
          pattern = "^(.)().-(.)()$",
        })
      end,
    },
  },
  aliases = {
    ["a"] = ">",
    ["b"] = ")",
    ["B"] = "}",
    ["q"] = { '"', "'", "`" },
    ["s"] = { "}", "]", ")", ">", '"', "'", "`" },
  },
  highlight = {
    duration = 0,
  },
  move_cursor = "begin",
  indent_lines = function(start, stop)
    local b = vim.bo
    if start < stop and (b.equalprg ~= "" or b.indentexpr ~= "" or b.cindent or b.smartindent or b.lisp) then
      vim.cmd(string.format("silent normal! %dG=%dG", start, stop))
      require("nvim-surround.cache").set_callback("")
    end
  end,
}

M.get_input = function(prompt)
  local input = require("nvim-surround.input")
  return input.get_input(prompt)
end

M.get_selection = function(args)
  if args.char then
    return M.get_find(args.char)(args.char)
  elseif args.motion then
    return require("nvim-surround.motions").get_selection(args.motion)
  elseif args.node then
    return require("nvim-surround.treesitter").get_selection(args.node)
  elseif args.pattern then
    return require("nvim-surround.patterns").get_selection(args.pattern)
  elseif args.query then
    return require("nvim-surround.queries").get_selection(args.query.capture, args.query.type)
  else
    vim.notify("Invalid key provided for `:h nvim-surround.config.get_selection()`.", vim.log.levels.ERROR)
  end
end

M.get_selections = function(args)
  local selection = M.get_selection({ char = args.char })
  if not selection then
    return nil
  end
  if args.pattern then
    return require("nvim-surround.patterns").get_selections(selection, args.pattern)
  else
    vim.notify("Invalid key provided for `:h nvim-surround.config.get_selections()`.", vim.log.levels.ERROR)
  end
end

return {
  "kylechui/nvim-surround",
  version = "^3.0.0",
  event = "VeryLazy",
  config = function()
    require("nvim-surround").setup(M.default_opts)
  end,
}
-- Keymaps are automatically loaded on the VeryLazy event
-- Default keymaps that are always set: https://github.com/LazyVim/LazyVim/blob/main/lua/lazyvim/config/keymaps.lua
-- Add any additional keymaps here
local map = vim.keymap.set
-- Delete on 'q' (next to 'w' where change is)
map({ "n", "o", "x" }, "x", "d", { desc = "Delete" })

-- Insert/append
map({ "x" }, "A", "i", { desc = "Insert before cursor" })
map({ "x" }, "H", "I", { desc = "Insert at start of line" })
map({ "x" }, "E", "a", { desc = "Insert after cursor" })
map({ "x" }, "I", "A", { desc = "Insert at end of line" })
-- Beginning/end of line
map({ "n", "o", "x" }, "0", "0", { desc = "Beginning of line" })
map({ "n", "o", "x" }, "p", "^", { desc = "First non-blank character" })
map({ "n", "o", "x" }, ".", "$", { desc = "End of line" })
-- Up/down/left/right
map({ "n", "o", "x" }, "h", "h", { desc = "Left (h)" })
map({ "n", "o", "x" }, "e", "k", { desc = "Up (k)" })
map({ "n", "o", "x" }, "a", "j", { desc = "Down (j)" })
map({ "n", "o", "x" }, "i", "l", { desc = "Right (l)" })

-- Line operations and find
map({ "n" }, "j", "o", { desc = "Open line below" })
map({ "n" }, "J", "O", { desc = "Open line above" })

-- PageUp/PageDown
map({ "n", "x" }, "<C-.>", "<PageUp>", { desc = "Page Up" })
map({ "n", "x" }, "<C-p>", "<PageDown>", { desc = "Page Down" })

-- Word left/right
map({ "n", "o", "x" }, "l", "b", { desc = "Word back" })
map({ "n", "o", "x" }, "d", "w", { desc = "Word forward" })
map({ "n", "o", "x" }, "L", "B", { desc = "WORD back" })
map({ "n", "o", "x" }, "D", "W", { desc = "WORD forward" })

-- Repeat find
map({ "n", "o", "x" }, ";", ";", { desc = "Repeat find forward" })
map({ "n", "o", "x" }, "-", ",", { desc = "Repeat find backward" })
map({ "n", "o", "x" }, "%", "%", { desc = "Jump to matching bracket" })

-- End of word left/right
map({ "n", "o", "x" }, "H", "ge", { desc = "End of word back" })
map({ "n", "o", "x" }, "<M-h>", "gE", { desc = "End of WORD back" })
map({ "n", "o", "x" }, "<M-o>", "E", { desc = "End of WORD forward" })

-- Text objects
-- diw is drw. daw is now dtw.
-- map({ "n", "o", "v" }, "r", "i", { desc = "O/V mode: inner (i)" })
-- map({ "n", "o", "v" }, "t", "a", { desc = "O/V mode: a/an (a)" })
-- map({ "v" }, "s", "<Plug>(nvim-surround-visual)", { desc = "Surround visual selection" })
--
-- Move lines with Alt+A/E
map({ "n" }, "<M-C-a>", "<cmd>move .+1<cr>==", { desc = "Move line down" })
map({ "n" }, "<M-C-e>", "<cmd>move .-2<cr>==", { desc = "Move line up" })

-- Simple operator-pending mappings for nvim-surround (using treesitter text objects)
map({ "o" }, "rd", "iw", { desc = "Inner word" })
map({ "o" }, "td", "aw", { desc = "Around word" })

-- Move visual replac.e from 'r' to 'R'
map({ "o", "v" }, "R", "r", { desc = "Replace" })

-- Folds
map({ "n", "x" }, "b", "z", { desc = "Fold commands" })
map({ "n", "x" }, "bb", "zb", { desc = "Scroll line and cursor to bottom" })
map({ "n", "x" }, "ba", "zj", { desc = "Move down to fold" })
map({ "n", "x" }, "be", "zk", { desc = "Move up to fold" })

-- Copy/paste
map({ "n", "o", "x" }, "c", "y", { desc = "Yank (copy)" })
map({ "n", "x" }, "v", "p", { desc = "Paste" })
map({ "n" }, "C", "y$", { desc = "Yank to end of line" })
map({ "x" }, "C", "y", { desc = "Yank selection" })
map({ "n", "x" }, "V", "P", { desc = "Paste before" })

-- Inline paste (avoids creating new lines)
local function paste_inline()
  local reg_type = vim.fn.getregtype('"')
  if reg_type == "V" then -- line-wise register
    vim.cmd("normal! gp")
  else
    vim.cmd("normal! p")
  end
end
map({ "n", "x" }, "<C-v>", paste_inline, { desc = "Paste inline" })

-- Undo/redo
map({ "n" }, "z", "u", { desc = "Undo" })
map({ "n" }, "<S-u>", "U", { desc = "Undo line" })
map({ "n" }, "<C-u>", "<C-r>", { desc = "Redo" })

-- Jumplist navigation
map({ "n" }, "o", "<C-o>", { desc = "Jumplist backward" })
map({ "n" }, "<C-o>", "<C-i>", { desc = "Jumplist forward" })

-- Change
map({ "n", "o", "x" }, "w", "c", { desc = "Change" })
map({ "n", "x" }, "W", "C", { desc = "Change to end of line" })

-- Visual mode
map({ "n", "x" }, "n", "v", { desc = "Visual mode" })
map({ "n", "x" }, "N", "V", { desc = "Visual line mode" })
-- Add Visual block mode
map({ "n" }, "<C-n>", "<C-v>", { desc = "Visual block mode" })

-- Override HAEI navigation in visual modes (including visual line mode)
-- Use noremap to fully override default vim behavior including text objects
map({ "x" }, "e", "k", { noremap = true, desc = "Up in visual modes" })
map({ "x" }, "a", "j", { noremap = true, desc = "Down in visual modes" })
map({ "x" }, "h", "h", { noremap = true, desc = "Left in visual modes" })
map({ "x" }, "i", "l", { noremap = true, desc = "Right in visual modes" })

map({ "n", "o", "x" }, "m", "n", { desc = "Next search match" })
map({ "n", "o", "x" }, "M", "N", { desc = "Previous search match" })

map({ "n" }, "<leader>gn", "<cmd>:Neogit cwd=%:p:h<CR>", { desc = "Open neogit" })
map({ "n" }, "<leader>gh", function()
  Snacks.terminal("gh dash", { win = { style = "terminal" } })
end, { desc = "Open GitHub dashboard" })

-- Lazygit
map({ "n" }, "<leader>gz", function()
  Snacks.lazygit()
end, { desc = "Lazygit (Root Dir)" })
map({ "n" }, "<leader>gZ", function()
  Snacks.lazygit({ cwd = LazyVim.root.get() })
end, { desc = "Lazygit (cwd)" })
-- 'til
map({ "n", "o", "x" }, "k", "t", { desc = "Till before" })
map({ "n", "o", "x" }, "K", "T", { desc = "Till before backward" })

-- Force override any plugin mappings for Q
vim.keymap.set("n", "Q", "@q", { desc = "replay the 'q' macro", silent = true, noremap = true })

-- Cursor to bottom of screen
-- H and M haven't been remapped, only L needs to be mapped
map({ "n" }, "B", "L", { desc = "Move to bottom of screen" })
map({ "v" }, "B", "L", { desc = "Move to bottom of screen" })
map({ "n", "v" }, "H", "H", { desc = "Move to top of screen" })

-- Misc overridden keys must be prefixed with g
map({ "n", "x" }, "gX", "X", { desc = "Delete before cursor" })
map({ "n", "x" }, "gU", "U", { desc = "Uppercase" })
map({ "n", "x" }, "gQ", "Q", { desc = "Ex mode" })
map({ "n", "x" }, "gK", "K", { desc = "Lookup keyword" })
-- extra alias (now main since K is remapped)
map({ "n", "x" }, "gh", "K", { desc = "Lookup keyword" })

-- Window navigation - cycle through windows
map({ "n" }, "<C-h>", "<C-w>w", { desc = "Previous window" })
map({ "n" }, "<C-i>", "<C-w>W", { desc = "Next window" })
--
-- Add some commonly used editor operations
map({ "n" }, "<leader>fs", ":w<CR>", { desc = "Save file" })
map({ "n" }, "<leader>q", ":q<CR>", { desc = "Quit" })
map({ "n" }, "<leader>Q", ":qa<CR>", { desc = "Quit all" })
map({ "n" }, "<leader>rr", function()
  vim.cmd("source " .. vim.fn.stdpath("config") .. "/lua/config/keymaps.lua")
  vim.notify("Keymaps reloaded")
end, { desc = "Reload keymaps" })

map({ "n" }, "<leader>rl", "<cmd>Lazy sync<cr>", { desc = "Lazy sync plugins" })
map({ "n" }, "<leader>ct", function()
  vim.cmd("split | terminal tsc --noEmit")
end, { desc = "TypeScript type check" })

map({ "n", "i", "v" }, "<F1>", "<nop>", { desc = "Disabled" })
map({ "n" }, "<F2>", "ggVG", { desc = "Select all" })

map({ "n", "o", "x" }, "<C-`>", function()
  Snacks.terminal()
end, { desc = "Toggle Terminal" })

-- Operator-pending mode mappings to help with nvim-surround
-- These allow your r/t mappings to work in operator-pending mode
map({ "v" }, "rd", "iw", { desc = "Inner word (visual)" })
map({ "v" }, "td", "aw", { desc = "Around word (visual)" })
map({ "o" }, "r(", "i(", { desc = "Inner parentheses (for nvim-surround)" })
map({ "o" }, "r)", "i)", { desc = "Inner parentheses (for nvim-surround)" })
map({ "o" }, "r[", "i[", { desc = "Inner brackets (for nvim-surround)" })
map({ "o" }, "r]", "i]", { desc = "Inner brackets (for nvim-surround)" })
map({ "o" }, "r{", "i{", { desc = "Inner braces (for nvim-surround)" })
map({ "o" }, "r}", "i}", { desc = "Inner braces (for nvim-surround)" })
map({ "o" }, 'r"', 'i"', { desc = "Inner quotes (for nvim-surround)" })
map({ "o" }, "r'", "i'", { desc = "Inner single quotes (for nvim-surround)" })
map({ "o" }, "t(", "a(", { desc = "Around parentheses (for nvim-surround)" })
map({ "o" }, "t)", "a)", { desc = "Around parentheses (for nvim-surround)" })
map({ "o" }, "t[", "a[", { desc = "Around brackets (for nvim-surround)" })
map({ "o" }, "t]", "a]", { desc = "Around brackets (for nvim-surround)" })
map({ "o" }, "t{", "a{", { desc = "Around braces (for nvim-surround)" })
map({ "o" }, "t}", "a}", { desc = "Around braces (for nvim-surround)" })
map({ "o" }, 't"', 'a"', { desc = "Around quotes (for nvim-surround)" })
map({ "o" }, "t'", "a'", { desc = "Around single quotes (for nvim-surround)" })

-- Snacks keymaps
-- local snacks_keymaps = require("config.keymaps-snacks")
-- map({ "n" }, "<leader>ti", snacks_keymaps.toggle_ignored, { desc = "Toggle snacks picker ignored files" })
-- map({ "n" }, "<leader>th", snacks_keymaps.toggle_hidden, { desc = "Toggle snacks picker hidden files" })
--
-- TypeScript Go to Source Definition with fallback to regular definition
map("n", "<leader>cc", function()
  local clients = vim.lsp.get_clients({ bufnr = 0 })
  if #clients == 0 then
    vim.notify("No LSP client attached", vim.log.levels.WARN)
    return
  end

  local position_params = vim.lsp.util.make_position_params(0, clients[1].offset_encoding)

  vim.lsp.buf_request(0, "workspace/executeCommand", {
    command = "typescript.goToSourceDefinition",
    arguments = { position_params.textDocument.uri, position_params.position },
  }, function(err, result, ctx, config)
    if err then
      vim.notify("Error: " .. tostring(err), vim.log.levels.ERROR)
      return
    end

    if not result or (type(result) == "table" and #result == 0) then
      vim.notify("No source definition found, trying regular definition", vim.log.levels.INFO)
      -- First try gd (floating window), then fall back to opening in new buffer
      vim.lsp.buf.definition({
        on_list = function(options)
          if options.items and #options.items > 0 then
            local item = options.items[1]
            vim.cmd("edit " .. item.filename)
            vim.api.nvim_win_set_cursor(0, { item.lnum, item.col - 1 })
          end
        end,
      })
      return
    end

    local location = result
    if type(result) == "table" and result[1] then
      location = result[1]
    end

    vim.lsp.util.jump_to_location(location, "utf-8")
  end)
end, { desc = "Go to source definition (fallback to definition)" })

-- Grug-far search within range
map({ "n", "x" }, "<leader>sR", function()
  require("grug-far").open({ visualSelectionUsage = "operate-within-range" })
end, { desc = "Search within range" })
-- Smart buffer delete function
local function smart_buffer_delete()
  local bufs = vim.tbl_filter(function(buf)
    return vim.api.nvim_buf_is_loaded(buf) and vim.bo[buf].buflisted
  end, vim.api.nvim_list_bufs())

  if #bufs <= 1 then
    vim.cmd("bd")
    require("snacks").dashboard()
  else
    vim.cmd("bd")
  end
end
map({ "n" }, "<C-w>w", smart_buffer_delete, { desc = "Close buffer" })
map({ "n" }, "<C-w>o", "<cmd>%bd|e#<CR>", { desc = "Close all buffers but current" })
map({ "n" }, "<leader>bd", smart_buffer_delete, { desc = "Delete Buffer" })
